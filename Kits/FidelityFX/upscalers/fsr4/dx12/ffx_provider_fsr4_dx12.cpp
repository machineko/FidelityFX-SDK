#define FFX_CPU

#include "../include/ffx_provider_fsr4.h"

#include <stdlib.h>
#include <assert.h>
#include <array>
#include <string_view>
#include <span>
#include <source_location>
#include <format>
#include <wrl/client.h>

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wsign-compare"
#pragma clang diagnostic ignored "-Wno-narrowing"
#endif

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4838)
#pragma warning(disable : 4996)
#endif

#include "../../../api/internal/ffx_backends.h"
#include "../../../api/internal/gpu/ffx_core.h"
#include "../../../api/internal/ffx_object_management.h"
#include "../../../api/internal/ffx_watermark.h"
#include "../../../api/internal/git_hash_branch.h"

#include "../internal/shader_selector.h"

#include "../../include/ffx_upscale.hpp"
#include "../../fsr3/include/ffx_fsr3upscaler.h"
#include "../../fsr3/include/gpu/fsr1/ffx_fsr1.h"

#include "../include/gpu/fsr4/ffx_fsr4upscaler_resources.h"

#define FFX_CPU
#include "../include/gpu/spd/ffx_spd.h"

#ifdef FFX_BACKEND_DX12
#include "../../../backend/dx12/ffx_dx12.h"
#endif // FFX_BACKEND_DX12

#define FSR4_ASSERT(_cond) Fsr4Assert(_cond, #_cond)

using namespace std::literals;

typedef struct ResourceBinding
{
    uint32_t index;
    wchar_t  name[64];
} ResourceBinding;

static const ResourceBinding srvTextureBindingTable[] = {
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_COLOR, L"r_input_color"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RCAS_TEMP, L"r_rcas_input"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS, L"r_velocity"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_DEPTH, L"r_depth"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_EXPOSURE, L"r_input_exposure"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_AUTO_EXPOSURE, L"r_auto_exposure_texture"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RECURRENT, L"r_recurrent_0"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_HISTORY, L"r_history_color"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_HISTORY_REPROJECTED, L"r_reprojected_color"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_DEBUG_INFORMATION, L"r_debug_visualization"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RESULT_COLOR, L"r_result_color"},

    {FFX_MLSR_BIND_SRV_INITIALIZER_BUFFER, L"InitializerBuffer"},
};

static const ResourceBinding uavTextureBindingTable[] = {
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RCAS_TEMP, L"rw_output_color_for_rcas"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_MLSR_OUTPUT, L"rw_mlsr_output_color"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_FINAL_OUTPUT, L"rw_final_output_color"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RCAS_OUTPUT, L"rw_rcas_output"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RECURRENT, L"rw_recurrent_0"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_HISTORY, L"rw_history_color"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_HISTORY_REPROJECTED, L"rw_reprojected_color"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_AUTO_EXPOSURE, L"rw_auto_exposure_texture"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT, L"rw_spd_global_atomic"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_SPD_MIP5, L"rw_autoexp_mip_5"},
    {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_DEBUG_INFORMATION, L"rw_debug_visualization"},

    {FFX_MLSR_BIND_SRV_SCRATCH_BUFFER, L"ScratchBuffer"},

};

static const ResourceBinding constantBufferBindingTable[] = {

    {FFX_FSR4UPSCALER_CONSTANTBUFFER_IDENTIFIER_FSR4UPSCALER, L"MLSR_Optimized_Constants"},
    {FFX_FSR4UPSCALER_CONSTANTBUFFER_IDENTIFIER_SPD_AUTOEXPOSURE, L"AutoExposureSPDConstants"},
    {FFX_FSR4UPSCALER_CONSTANTBUFFER_IDENTIFIER_RCAS, L"cbRCAS"},
    {FFX_FSR4UPSCALER_CONSTANTBUFFER_IDENTIFIER_PASS_WEIGHTS, L"cbPass_Weights"},
};

FFX_API bool ffxFsr4UpscalerResourceIsNull(FfxApiResource resource)
{
    return resource.resource == NULL;
}

static void Fsr4AssertFail(const char* condStr, std::source_location loc)
{
    struct DebugFormatIterator
    {
        using difference_type = ptrdiff_t;

        char buffer[65];
        size_t buffered = 0;

        void Flush()
        {
            if (buffered > 0)
            {
                buffer[buffered] = 0;
                OutputDebugStringA(buffer);
                buffered = 0;
            }
        }

        DebugFormatIterator& operator=(char c)
        {
            buffer[buffered] = c;
            buffered++;
            if (buffered >= 64) Flush();
            return *this;
        }

        DebugFormatIterator& operator*() { return *this; }
        DebugFormatIterator& operator++() { return *this; }
        DebugFormatIterator& operator++(int) { return *this; }

        ~DebugFormatIterator()
        {
            Flush();
        }
    };

    std::format_to(DebugFormatIterator{}, "Assertion failed: {}\n    In function {} ({}:{})", condStr, loc.function_name(), loc.file_name(), loc.line());

    if (IsDebuggerPresent())
        DebugBreak();
}

static inline void Fsr4Assert(bool condition, const char* condStr, std::source_location loc = std::source_location::current())
{
    if (!condition)
    {
        Fsr4AssertFail(condStr, loc);
    }
}

static inline void AssertOk(HRESULT hr, std::source_location loc = std::source_location::current())
{
    if (FAILED(hr))
    {
        Fsr4AssertFail("HRESULT", loc);
    }
}

template<typename T>
static inline T RoundUpDiv(T a, T b)
{
    return (a - T(1) + b) / b;
}

template<typename T>
static inline T AlignUp(T val, T align)
{
    // produces optimal code for align=power of 2
    return RoundUpDiv(val, align) * align;
}

template<typename T>
using ComPtr = Microsoft::WRL::ComPtr<T>;

bool ffxProvider_FSR4::CanProvide(uint64_t type) const
{
    return (type & FFX_API_EFFECT_MASK) == FFX_API_EFFECT_ID_UPSCALE;
}

bool EnableAMDExtensions(void* device);

bool ffxProvider_FSR4::IsSupported(void* device) const
{
    if (!device) return false;
    return EnableAMDExtensions(device);
}

ffxProvider_FSR4::ffxProvider_FSR4()
{
}

// If you change versioning in GetId() and GetVersionName(), you must also update the DLL
// version defines in ./resource/resource.h
uint64_t ffxProvider_FSR4::GetId() const
{
    // FSR Scale, pseudo-version based on model version
    return 0xF5A5'CA1Eui64 << 32 | (FFX_SDK_MAKE_VERSION(4, 0, 2) & 0xFFFF'FFFF);
}

const char* ffxProvider_FSR4::GetVersionName() const
{
    return "4.0.2";
}

struct alignas(256) OptimizedConstants
{
    float inv_size[2];
    float scale[2];
    float inv_scale[2];
    float jitter[2];
    float mv_scale[2];
    float tex_size[2];
    float max_renderSize[2];
    float fMotionVectorJitterCancellation[2];

    uint32_t width;
    uint32_t height;
    uint32_t reset;
    uint32_t width_lr;

    uint32_t height_lr;
    float preExposure;
    float previous_preExposure;
    uint32_t rcas_enabled;

    float rcas_sharpness;
    float _pad1;
};

struct alignas(256) AutoExposureSPDConstants
{
    uint32_t mips;
    uint32_t numWorkGroups;
    uint32_t workGroupOffset[2];
    float    invInputSize[2]; // Only used for linear sampling mode
    float    preExposure;
    float    padding;
};

struct alignas(256) RcasConstants
{
    uint32_t config[4];
    float    preExposure;
    uint32_t _pad[3];
};

struct alignas(256) Pass0Weights
{
    uint32_t embedded_encoder1_DownscaleStridedConv2x2_downscale_conv_weight_dwords[256];
};
static const uint32_t weights_native[256] = {
    // -0.02858, 0.12384, 0.836, -0.03099, -0.2406, 0.04132, -0.04358, 0.0, -0.0103, 0.32, 0.3079, 0.09106, -0.03067, 0.1985, -0.1641, 0.0
    0x2feda751, 0xa7ef3ab0, 0x294ab3b3, 0xa994, 0x351fa146, 0x2dd434ed, 0x325aa7da, 0xb140,
    // -0.2228, 0.04587, 0.873, -0.00801, 0.00488, -0.4014, 0.1464, 0.0, -0.2788, 0.1927, 0.8574, -0.077, -0.1604, 0.02861, -0.0769, 0.0
    0x29dfb321, 0xa01a3afc, 0xb66c1cff, 0x30af, 0x322bb476, 0xacee3adc, 0x2753b122, 0xacec,
    // 0.07056, -0.2017, -0.11053, -0.3743, 0.03537, 0.195, -0.02898, 0.0, 0.1631, -0.2698, -0.1566, -0.5166, -0.003128, 0.197, 0.000514, 0.0
    0xb2742c84, 0xb5fdaf13, 0x323d2887, 0xa76b, 0xb4513138, 0xb822b103, 0x324e9a68, 0x1036,
    // 0.2317, -0.1798, -0.0406, -0.6167, 0.09625, 0.2688, 0.1832, 0.0, 0.3254, -0.2034, 0.11414, -0.4229, 0.182, 0.1682, -0.0443, 0.0
    0xb1c1336a, 0xb8efa932, 0x344d2e29, 0x31dd, 0xb2823535, 0xb6c42f4e, 0x316231d3, 0xa9ac,
    // 0.01095, 0.2457, -0.5786, -0.4363, 0.286, 0.0582, 0.0875, 0.0, -0.12, 0.3787, -0.3752, -0.4114, 0.4395, -0.2502, 0.1876, 0.0
    0x33dd219b, 0xb6fbb8a1, 0x2b733493, 0x2d9a, 0x360fafae, 0xb695b601, 0xb4013708, 0x3201,
    // -0.2118, 0.2388, -0.3772, -0.4084, 0.3877, 0.0563, -0.183, 0.0, -0.3042, 0.08685, -0.6494, -0.304, 0.04547, 0.0969, 0.09106, 0.0
    0x33a4b2c7, 0xb689b609, 0x2b353634, 0xb1db, 0x2d8fb4de, 0xb4ddb932, 0x2e3429d2, 0x2dd4,
    // -0.2408, 0.2074, 0.9937, -0.0925, 0.1947, -0.0446, -0.01215, 0.0, -0.2925, 0.03793, 0.928, -0.0746, 0.02773, 0.03952, -0.02176, 0.0
    0x32a3b3b5, 0xadec3bf3, 0xa9b5323b, 0xa239, 0x28dbb4ae, 0xacc63b6d, 0x290f2719, 0xa592,
    // 0.1892, 0.1975, 0.5303, 0.02046, -0.0438, -0.02711, 0.000343, 0.0, -0.01181, -0.05585, 0.8247, 0.04184, -0.06744, -0.01898, -0.02841, 0.0
    0x3252320e, 0x253d383e, 0xa6f1a99b, 0xd9f, 0xab26a20c, 0x295b3a99, 0xa4dcac51, 0xa746,
    // -0.2505, -0.03354, 0.1199, 0.006634, -0.01218, 0.002306, 0.001922, 0.0, 0.6094, -0.2717, -0.2449, 0.00798, -0.03278, -0.005608, 0.02238, 0.0
    0xa84bb402, 0x1ecb2fac, 0x18b9a23c, 0x17df, 0xb45938e0, 0x2016b3d6, 0x9dbea832, 0x25bb,
    // 0.1407, 0.1904, -0.1609, 0.00948, -0.009254, 0.0283, 0.012146, 0.0, -0.3882, 0.01103, 0.05496, 0.00702, 0.00538, 0.001417, 0.007904, 0.0
    0x32183081, 0x20dbb126, 0x273fa0bd, 0x2238, 0x21a6b636, 0x1f302b09, 0x15ce1d82, 0x200c,
    // 0.04004, -0.111, 1.005, 0.002779, -0.04166, -0.00429, -0.00829, 0.0, 0.0765, -0.06445, 0.9927, -0.03864, 0.1031, -0.1343, 0.03085, 0.0
    0xaf1b2920, 0x19b13c05, 0x9c65a955, 0xa03f, 0xac202ce5, 0xa8f23bf1, 0xb04c2e99, 0x27e6,
    // 0.04144, 0.0003097, 0.9272, 0.0307, 0.0702, 0.0473, -0.0991, 0.0, 0.08496, 0.04544, 1.007, 0.003164, 0.0764, -0.02371, -0.003326, 0.0
    0xd13294e, 0x27dc3b6b, 0x2a0e2c7e, 0xae58, 0x29d12d70, 0x1a7b3c07, 0xa6122ce4, 0x9ad0,
    // 0.10284, 0.0625, -0.1827, 0.02759, 0.167, -0.02275, -0.0375, 0.0, -0.05804, 0.1733, 0.2812, -0.2012, 0.0963, 0.1041, -0.0764, 0.0
    0x2c002e95, 0x2710b1d9, 0xa5d33158, 0xa8cd, 0x318cab6e, 0xb2703480, 0x2eaa2e2a, 0xace4,
    // -0.1394, 0.0765, -0.2228, -0.00676, -0.1815, 0.2336, 0.005753, 0.0, -0.3296, 0.1731, 0.2356, -0.01909, 0.2423, -0.05066, -0.03004, 0.0
    0x2ce5b076, 0x9eecb321, 0x337ab1cf, 0x1de4, 0x318ab546, 0xa4e3338a, 0xaa7c33c1, 0xa7b1,
    // -0.2179, 0.1542, -0.04465, -0.06616, 0.169, -0.05167, 0.02644, 0.0, 0.3894, -0.09174, 0.0494, -0.11145, 0.1512, 0.0698, -0.0365, 0.0
    0x30efb2f9, 0xac3ca9b7, 0xaa9d3168, 0x26c5, 0xaddf363b, 0xaf222a53, 0x2c7830d7, 0xa8ac,
    // -0.6064, 0.1758, 0.02998, 0.01717, -0.001664, -0.06, 0.0673, 0.0, 0.402, -0.1416, -0.0687, -0.00438, -0.007866, -0.04333, -0.01179, 0.0
    0x31a0b8da, 0x246527ad, 0xabae96d1, 0x2c4f, 0xb088366f, 0x9c7cac66, 0xa98ca007, 0xa209,
    // -0.2083, 0.084, 0.5225, 0.04782, -0.00921, 0.1077, -0.04108, 0.0, -0.1439, 0.08374, 0.2418, 0.04684, -0.01784, 0.07886, -0.1423, 0.0
    0x2d60b2aa, 0x2a1f382e, 0x2ee5a0b7, 0xa942, 0x2d5cb09b, 0x29ff33bd, 0x2d0ca491, 0xb08e,
    // -0.2974, 0.122, 0.4607, -0.07434, 0.0669, 0.22, -0.1919, 0.0, -0.1711, 0.1394, 0.2834, 0.0744, 0.0002137, 0.1197, -0.01536, 0.0
    0x2fcfb4c2, 0xacc2375f, 0x330a2c48, 0xb224, 0x3076b17a, 0x2cc33489, 0x2fa90b01, 0xa3dd,
    // 0.3376, -0.2013, 0.722, 0.007687, 0.06696, -0.004135, -0.01653, 0.0, 0.321, -0.2122, 0.6133, 0.0355, -0.03592, -0.0363, -0.005417, 0.0
    0xb2713567, 0x1fdf39c7, 0x9c3c2c49, 0xa43b, 0xb2ca3523, 0x288b38e8, 0xa8a5a899, 0x9d8c,
    // -0.0658, -0.2301, 0.384, 0.0847, -0.2035, 0.05753, -0.1302, 0.0, 0.1798, -0.12396, 0.601, 0.08673, -0.0538, 0.01636, 0.0425, 0.0
    0xb35dac36, 0x2d6c3625, 0x2b5db283, 0xb02b, 0xafef31c1, 0x2d8d38cf, 0x2430aae3, 0x2971,
    // -0.419, 0.0466, 0.2693, 0.001134, 0.0314, -0.0618, -0.0488, 0.0, -0.1853, 0.2023, -0.06155, 0.0145, -0.1455, -0.0573, 0.10596, 0.0
    0x29f7b6b4, 0x14a5344f, 0xabe92805, 0xaa3f, 0x3279b1ee, 0x236dabe1, 0xab56b0a8, 0x2ec8,
    // -0.2563, 0.2556, -0.01245, -0.1278, -0.00913, -0.003933, 0.02635, 0.0, 0.0681, 0.321, -0.05493, -0.06635, 0.2556, -0.0771, 0.001173, 0.0
    0x3417b41a, 0xb017a260, 0x9c07a0ad, 0x26bf, 0x35232c5c, 0xac3fab08, 0xacef3417, 0x14ce,
    // 0.415, -0.0938, -0.5044, -0.01712, -0.1175, 0.01666, 0.0348, 0.0, -0.126, -0.4224, -0.1693, -0.0576, 0.03238, 0.108, -0.02948, 0.0
    0xae0136a4, 0xa462b809, 0x2444af85, 0x2874, 0xb6c2b008, 0xab5fb16b, 0x2ee92825, 0xa78c,
    // -0.2603, 0.513, -0.001765, 0.04053, 0.004276, -0.12415, 0.09906, 0.0, -0.0849, 0.07623, -0.2057, -0.06946, 0.02473, -0.005543, 0.03748, 0.0
    0x381bb42a, 0x2930973b, 0xaff21c61, 0x2e57, 0x2ce1ad6f, 0xac72b295, 0x9dad2655, 0x28cc,
    // 0.223, -0.09924, -0.012054, 0.02768, 0.2803, -0.0734, -7.83e-05, 0.0, 0.182, -0.1329, -0.4355, 0.0336, 0.03128, 0.273, -0.1167, 0.0
    0xae5a3323, 0x2716a22c, 0xacb3347c, 0x8522, 0xb04131d3, 0x284db6f8, 0x345e2801, 0xaf78,
    // 0.2666, -0.1752, 0.003618, -0.1818, 0.146, -0.10913, 0.02501, 0.0, 0.1776, -0.0561, -0.4329, 0.03494, 0.2373, -0.0524, 0.01009, 0.0
    0xb19b3444, 0xb1d11b69, 0xaefc30ac, 0x2667, 0xab2e31af, 0x2879b6ed, 0xaab53398, 0x212b,
    // -0.02617, 0.02373, 0.0861, -0.0959, -0.12286, 0.08954, 0.3308, 0.0, 0.01692, 0.083, 0.11053, -0.1558, -0.2373, 0.1289, 0.3162, 0.0
    0x2613a6b3, 0xae232d83, 0x2dbbafdd, 0x354b, 0x2d502455, 0xb0fc2f13, 0x3020b398, 0x350f,
    // -0.01613, -0.02748, 0.2239, -0.1398, -0.135, 0.10645, 0.3804, 0.0, -0.01636, 0.02568, 0.138, -0.0169, -0.1431, 0.0837, 0.3215, 0.0
    0xa709a421, 0xb079332a, 0x2ed0b052, 0x3616, 0x2693a430, 0xa454306a, 0x2d5bb094, 0x3525,
    // -0.5396, -0.04337, -0.5947, 0.0657, -0.1399, 0.04236, 0.04477, 0.0, -0.08386, 0.0455, -0.3323, -0.1081, 0.3, 0.1694, -0.179, 0.0
    0xa98db851, 0x2c34b8c2, 0x296cb07a, 0x29bb, 0x29d3ad5e, 0xaeebb551, 0x316c34cd, 0xb1ba,
    // 0.2866, -0.10693, -0.597, 0.1787, -0.1366, -0.07416, -0.02122, 0.0, 0.276, 0.04126, -0.6055, -0.05798, 0.07904, 0.001187, 0.06137, 0.0
    0xaed83496, 0x31b8b8c7, 0xacbfb05f, 0xa56f, 0x2948346a, 0xab6cb8d8, 0x14dd2d0f, 0x2bdb,
    // -0.03952, 0.1901, -0.9087, 0.1802, -0.229, 0.143, -0.0726, 0.0, -0.0167, 0.06976, -0.724, 0.1818, -0.1866, 0.02629, -0.1517, 0.0
    0x3215a90f, 0x31c4bb45, 0x3093b354, 0xaca5, 0x2c77a446, 0x31d1b9cb, 0x26bbb1f9, 0xb0db,
    // 0.05292, 0.2722, -0.9, 0.1592, -0.1365, 0.2542, -0.117, 0.0, 0.2074, 0.0996, -0.864, 0.1527, -0.2435, 0.1395, -0.07745, 0.0
    0x345b2ac6, 0x3118bb33, 0x3411b05e, 0xaf7d, 0x2e6032a3, 0x30e3bae9, 0x3077b3cb, 0xacf5,
};
static const uint32_t weights_quality[256] = {
    // -0.011314, 0.04135, 0.652, 0.06836, -0.1022, -0.12164, -0.2129, 0.0, -0.01913, 0.10583, 0.794, 0.002829, 0.04358, -0.2, -0.0768, 0.0
    0x294ba1cb, 0x2c603937, 0xafc9ae8a, 0xb2d0, 0x2ec6a4e6, 0x19cb3a5a, 0xb2662994, 0xacea,
    // -0.1427, 0.0942, 0.9043, 0.00679, 0.06793, -0.2856, -0.1302, 0.0, -0.1087, 0.1597, 0.8145, 0.0495, -0.00827, -0.1794, -0.007755, 0.0
    0x2e07b091, 0x1ef43b3c, 0xb4922c59, 0xb02b, 0x311caef5, 0x2a563a84, 0xb1bea03c, 0x9ff1,
    // -0.0634, -0.01279, -0.1611, -0.12415, 0.1431, -0.2544, 0.3198, 0.0, 0.05038, -0.09705, -0.5303, -0.1053, -0.09985, -0.1066, 0.2483, 0.0
    0xa28cac0f, 0xaff2b128, 0xb4123094, 0x351e, 0xae362a73, 0xaebdb83e, 0xaed3ae64, 0x33f2,
    // 0.1758, -0.04337, -0.3828, -0.3157, 0.0689, -0.2446, 0.3025, 0.0, 0.3313, -0.2191, -0.4814, -0.1624, -0.1907, -0.05334, 0.2532, 0.0
    0xa98d31a0, 0xb50db620, 0xb3d42c69, 0x34d7, 0xb303354d, 0xb132b7b4, 0xaad4b21a, 0x340d,
    // -0.1309, 0.2214, -0.4614, 0.1089, -0.1709, 0.1478, -0.1334, 0.0, -0.1925, 0.2056, -0.2183, 0.1644, -0.1311, 0.1844, 0.0173, 0.0
    0x3316b030, 0x2ef8b762, 0x30bbb178, 0xb045, 0x3294b229, 0x3143b2fc, 0x31e7b032, 0x246e,
    // -0.1803, 0.05835, -0.4568, 0.003595, 0.185, -0.165, -0.05032, 0.0, -0.26, 0.0732, -0.2137, -0.0862, 0.1235, 0.1318, -0.01863, 0.0
    0x2b78b1c5, 0x1b5db74f, 0xb14831ec, 0xaa71, 0x2cafb429, 0xad84b2d7, 0x30382fe7, 0xa4c5,
    // -0.04245, 0.2578, -0.0457, 0.1956, -0.0995, -0.02332, -0.06995, 0.0, -0.3762, -0.0003214, -0.1171, 0.0505, 0.03918, -0.096, -0.1533, 0.0
    0x3420a96f, 0x3242a9d9, 0xa5f8ae5e, 0xac7a, 0x8d44b605, 0x2a77af7f, 0xae252904, 0xb0e8,
    // 0.172, 0.1343, -0.1009, -0.05914, 0.02327, 0.0003922, 0.06274, 0.0, -0.0876, -0.05383, -0.05145, -0.1301, 0.08154, -0.04956, 0.014595, 0.0
    0x304c3181, 0xab92ae75, 0xe6d25f5, 0x2c04, 0xaae4ad9b, 0xb02aaa96, 0xaa582d38, 0x2379,
    // 0.2094, 0.2944, 0.04684, -0.03265, -0.00526, 0.07434, 0.0718, 0.0, 0.11426, -0.03098, 0.1216, 0.00827, 0.02696, -0.01214, -0.037, 0.0
    0x34b632b3, 0xa82e29ff, 0x2cc29d63, 0x2c98, 0xa7ee2f50, 0x203c2fc8, 0xa23726e7, 0xa8bc,
    // -0.541, 0.03586, 0.2676, 0.01357, -0.06042, 0.05853, 0.03111, 0.0, 0.04108, -0.1443, -2.15e-05, -0.03226, -0.000743, 0.01185, -0.0463, 0.0
    0x2897b854, 0x22f33448, 0x2b7eabbc, 0x27f7, 0xb09e2942, 0xa8218169, 0x22119216, 0xa9ed,
    // 0.1885, 0.221, 0.1509, -0.0192, -0.0191, 0.1809, -0.05182, 0.0, 0.08295, 0.2157, 0.2279, -0.04962, 0.0929, 0.204, -0.0749, 0.0
    0x33123208, 0xa4ea30d4, 0x31caa4e4, 0xaaa2, 0x32e72d4f, 0xaa5a334b, 0x32872df2, 0xaccb,
    // 0.1118, 0.1946, 0.2463, -0.2502, 0.262, 0.1099, 0.03427, 0.0, -0.0599, 0.1871, 0.265, -0.3213, 0.2096, 0.252, -0.09406, 0.0
    0x323a2f28, 0xb40133e2, 0x2f093431, 0x2863, 0x31fdabab, 0xb524343d, 0x340832b5, 0xae05,
    // -0.05484, 0.1433, -0.1536, -0.0755, 0.1658, -0.2474, 0.1459, 0.0, -0.2683, 0.2189, -0.1729, -0.2365, -0.006264, 0.1377, -0.06885, 0.0
    0x3096ab05, 0xacd5b0ea, 0xb3eb314e, 0x30ab, 0x3301b44b, 0xb391b188, 0x30689e6a, 0xac68,
    // -0.10333, 0.0728, -0.3425, 0.11664, -0.1293, 0.0645, -0.0582, 0.0, -0.1714, 0.2216, -0.2998, -0.09174, 0.05676, -0.012245, 0.126, 0.0
    0x2ca9ae9d, 0x2f77b57b, 0x2c21b023, 0xab73, 0x3317b17c, 0xaddfb4cc, 0xa2452b44, 0x3008,
    // -0.3003, 0.432, -0.1715, -0.01637, 0.06396, 0.0922, -0.011505, 0.0, -0.01146, 0.1364, -0.2, 0.0919, -0.07947, 0.04224, -0.02853, 0.0
    0x36e9b4ce, 0xa431b17d, 0x2de72c18, 0xa1e4, 0x305da1de, 0x2de2b266, 0x2968ad16, 0xa74e,
    // 0.0938, 0.0848, -0.279, 0.0781, -0.08514, 0.02122, -0.0904, 0.0, -0.02112, -0.19, -0.1198, 0.254, 0.05588, -0.4104, 0.00423, 0.0
    0x2d6d2e01, 0x2d00b477, 0x256fad73, 0xadc9, 0xb214a568, 0x3410afab, 0xb6912b27, 0x1c55,
    // -0.4883, 0.0852, -0.2338, 0.1055, -0.08624, -0.02003, -0.02846, 0.0, 0.2798, 0.08997, -0.3186, -0.0678, 0.02773, 0.0164, -0.0715, 0.0
    0x2d74b7d0, 0x2ec1b37b, 0xa521ad85, 0xa749, 0x2dc2347a, 0xac57b519, 0x24332719, 0xac93,
    // -0.315, 0.1134, -0.383, -0.011894, 0.02481, 0.03317, 0.02063, 0.0, 0.1389, 0.0999, -0.2037, -0.1271, 0.08014, 0.0423, 0.04153, 0.0
    0x2f42b50a, 0xa217b621, 0x283f265a, 0x2548, 0x2e653072, 0xb011b285, 0x296a2d21, 0x2951,
    // 0.1481, -0.12225, 0.4138, 0.10156, 0.08246, -0.1188, 0.006115, 0.0, 0.1584, -0.1195, 0.6084, 0.04678, -0.008316, 0.03018, -0.00661, 0.0
    0xafd330bd, 0x2e80369f, 0xaf9a2d47, 0x1e43, 0xafa63112, 0x29fd38de, 0x27baa042, 0x9ec5,
    // 0.0907, -0.1383, 0.5977, 0.012024, 0.04514, -0.02925, 0.014366, 0.0, 0.1144, -0.1642, 0.58, -0.09204, 0.1866, -0.0979, 0.1381, 0.0
    0xb06d2dce, 0x222838c8, 0xa77d29c7, 0x235b, 0xb1412f52, 0xade438a4, 0xae4431f9, 0x306b,
    // -0.2034, 0.08276, 0.2803, 0.10406, 0.3687, -0.2476, -0.1241, 0.0, -0.1887, 0.1464, 0.131, 0.3027, -0.007706, -0.043, -0.1613, 0.0
    0x2d4cb282, 0x2ea9347c, 0xb3ec35e6, 0xaff1, 0x30afb20a, 0x34d83031, 0xa9819fe4, 0xb129,
    // -0.1982, 0.1985, 0.4573, -0.015526, 0.0738, 0.02505, -0.1295, 0.0, -0.07544, 0.2888, 0.2742, 0.08594, -0.076, 0.03552, -0.1716, 0.0
    0x325ab258, 0xa3f33751, 0x266a2cb9, 0xb025, 0x349facd4, 0x2d803463, 0x288cacdd, 0xb17e,
    // -0.10913, 0.09454, 0.1615, -0.1647, 0.2766, -0.02646, 0.06683, 0.0, -0.1464, 0.1102, 0.04565, -0.1444, 0.3127, -0.213, 0.1118, 0.0
    0x2e0daefc, 0xb145312b, 0xa6c6346d, 0x2c47, 0x2f0eb0af, 0xb09f29d8, 0xb2d13501, 0x2f28,
    // -0.1868, 0.1081, 0.1351, -0.1938, 0.2573, -0.088, 0.089, 0.0, -0.227, 0.116, -0.03278, -0.0817, 0.1796, -0.1643, 0.0809, 0.0
    0x2eebb1fa, 0xb2343053, 0xada2341e, 0x2db2, 0x2f6db344, 0xad3ba832, 0xb14231bf, 0x2d2d,
    // 0.02751, -0.11487, -0.04114, -0.1476, 0.2935, 0.01749, -0.386, 0.0, 0.09937, -0.1353, -0.178, -0.1914, 0.2798, 0.2218, -0.5977, 0.0
    0xaf5a270b, 0xb0b9a944, 0x247a34b2, 0xb62d, 0xb0542e5c, 0xb220b1b2, 0x3319347a, 0xb8c8,
    // 0.1208, -0.1555, -0.01596, -0.1495, 0.2676, 0.1909, -0.427, 0.0, 0.1279, -0.1956, -0.1422, -0.2844, 0.2426, 0.1681, -0.506, 0.0
    0xb0fa2fbb, 0xb0c9a416, 0x321c3448, 0xb6d5, 0xb2423018, 0xb48db08d, 0x316133c3, 0xb80c,
    // 0.2698, -0.1799, -0.6562, 0.06573, -0.01437, -0.02061, -0.03085, 0.0, 0.2715, -0.0997, -0.904, 0.086, -0.11444, 0.01551, -0.11926, 0.0
    0xb1c23451, 0x2c35b940, 0xa547a35c, 0xa7e6, 0xae613458, 0x2d81bb3b, 0x23f1af53, 0xafa2,
    // -0.10364, 0.00968, -0.8228, -0.01238, -0.02776, -0.01723, -0.02718, 0.0, -0.2307, 0.07355, -0.7144, 0.0717, 0.06354, -0.262, 0.05045, 0.0
    0x20f5aea2, 0xa257ba95, 0xa469a71b, 0xa6f5, 0x2cb5b362, 0x2c97b9b7, 0xb4312c11, 0x2a75,
    // -0.0868, -0.1372, 0.0278, -0.02687, -0.12274, 0.1777, -0.087, 0.0, -0.226, -0.02454, 0.05493, 0.075, -0.0591, 0.07214, -0.0694, 0.0
    0xb064ad8e, 0xa6e1271e, 0x31b0afdb, 0xad91, 0xa648b33b, 0x2ccd2b08, 0x2c9eab91, 0xac71,
    // -0.0328, -0.01683, 0.0525, 0.0519, 0.02913, -0.02748, -0.0803, 0.0, 0.4053, 0.1235, -0.1732, 0.0375, 0.2328, -0.2069, 0.02446, 0.0
    0xa44fa833, 0x2aa52ab8, 0xa7092775, 0xad24, 0x2fe7367c, 0x28cdb18b, 0xb29f3373, 0x2643,
    // 0.1552, -0.01433, -0.8867, 0.10297, 0.1515, -0.1405, -0.11884, 0.0, 0.0697, -0.03528, -0.784, 0.107, 0.1924, -0.264, 0.03082, 0.0
    0xa35630f7, 0x2e97bb18, 0xb07f30d9, 0xaf9b, 0xa8842c76, 0x2ed9ba46, 0xb4393228, 0x27e4,
    // 0.10657, -0.1187, -0.9536, 0.1862, 0.1432, -0.2494, -0.09753, 0.0, 0.2028, -0.1315, -0.892, 0.1736, -0.02547, -0.04352, -0.04282, 0.0
    0xaf992ed2, 0x31f5bba1, 0xb3fb3095, 0xae3e, 0xb035327d, 0x318ebb23, 0xa992a685, 0xa97b,
};
static const uint32_t weights_balanced[256] = {
    // -0.0894, 0.03308, -0.0265, -0.1022, -0.0827, 0.04953, -0.0802, 0.0, 0.1515, 0.1754, 0.1451, 0.0462, -0.3318, 0.1954, -0.0876, 0.0
    0x283cadb9, 0xae8aa6c9, 0x2a57ad4b, 0xad22, 0x319d30d9, 0x29ea30a5, 0x3241b54f, 0xad9b,
    // -0.2355, 0.111, 0.0262, -0.2368, -0.0355, -0.3896, -0.03174, 0.0, -0.10175, 0.0899, 0.2615, -0.1781, -0.0327, 0.08655, -0.0434, 0.0
    0x2f1bb389, 0xb39426b5, 0xb63ca88b, 0xa810, 0x2dc1ae83, 0xb1b3342f, 0x2d8aa830, 0xa98e,
    // 0.02881, -0.1323, -0.662, -0.2351, 0.1006, 0.0763, 0.05048, 0.0, 0.1655, -0.1742, -0.6807, -0.0955, 0.12, -0.1764, -0.1423, 0.0
    0xb03c2760, 0xb386b94c, 0x2ce22e70, 0x2a76, 0xb193314c, 0xae1db972, 0xb1a52fae, 0xb08e,
    // 0.2537, -0.2817, -0.725, 0.05222, -0.0425, 0.06192, -0.0261, 0.0, 0.3704, -0.2068, -0.769, -0.0459, 0.0572, 0.0305, -0.0851, 0.0
    0xb482340f, 0x2aafb9cd, 0x2beda971, 0xa6ae, 0xb29e35ed, 0xa9e0ba27, 0x27cf2b52, 0xad72,
    // -0.1985, 0.09125, -0.832, 0.0262, -0.0788, -0.06805, 0.1176, 0.0, -0.12274, 0.11444, -0.7715, -0.02756, -0.01537, -0.00946, 0.1542, 0.0
    0x2dd7b25a, 0x26b5baa8, 0xac5bad0b, 0x2f87, 0x2f53afdb, 0xa70eba2c, 0xa0d8a3df, 0x30ef,
    // -0.167, 0.108, -0.864, -0.1243, 0.03287, -0.014366, 0.00821, 0.0, -0.1656, 0.0565, -0.8774, 0.03836, 0.00822, -0.0931, -0.03842, 0.0
    0x2ee9b158, 0xaff5bae9, 0xa35b2835, 0x2034, 0x2b3bb14d, 0x28e9bb05, 0xadf52035, 0xa8eb,
    // -0.02553, -0.01422, -0.5464, 0.04153, -0.0411, -0.02615, 0.012726, 0.0, -0.2778, -0.301, -0.5986, 0.1372, -0.02245, -0.01036, -0.1765, 0.0
    0xa348a689, 0x2951b85f, 0xa6b2a943, 0x2284, 0xb4d1b472, 0x3064b8ca, 0xa14ea5bf, 0xb1a6,
    // 0.366, 0.4536, -0.4097, -0.1144, -0.05844, 0.1, 0.247, 0.0, -0.2452, 0.03143, -0.3662, -0.083, -0.04608, 0.08026, 0.01604, 0.0
    0x374235db, 0xaf52b68e, 0x2e66ab7b, 0x33e7, 0x2806b3d9, 0xad50b5dc, 0x2d23a9e6, 0x241b,
    // 0.6855, -0.0812, -0.0809, -0.2278, 0.01886, 0.0804, 0.06024, 0.0, 0.3555, -0.12274, -0.1698, -0.272, 0.174, -0.2256, 0.05438, 0.0
    0xad32397c, 0xb34aad2d, 0x2d2524d4, 0x2bb6, 0xafdb35b0, 0xb45ab16f, 0xb3383191, 0x2af6,
    // 0.1804, -0.02812, -0.294, 0.1034, -0.0869, 0.1962, -0.153, 0.0, -0.5786, -0.1619, -0.185, 0.1455, 0.0788, -0.0818, -0.1884, 0.0
    0xa73331c6, 0x2e9eb4b4, 0x3247ad90, 0xb0e5, 0xb12eb8a1, 0x30a8b1ec, 0xad3c2d0b, 0xb207,
    // -0.2335, 0.07764, -0.0863, 0.1372, -0.06665, -0.1658, 0.1802, 0.0, 0.2698, 0.1713, -0.448, 0.07025, -0.154, -0.072, 0.1876, 0.0
    0x2cf8b379, 0x3064ad86, 0xb14eac44, 0x31c4, 0x317b3451, 0x2c7fb72b, 0xac9cb0ee, 0x3201,
    // 0.3572, -0.026, -0.2471, -0.06854, 0.1571, -0.1403, 0.064, 0.0, 0.2751, 0.01376, -0.2651, -0.1694, 0.00878, -0.0007663, 0.0824, 0.0
    0xa6a835b7, 0xac63b3e8, 0xb07d3107, 0x2c19, 0x230c3467, 0xb16cb43e, 0x9247207f, 0x2d46,
    // -0.09375, 0.0638, -0.0665, 0.003744, -0.02377, 0.009415, -0.04068, 0.0, -0.2622, 0.4497, -0.06027, -0.00514, -0.00555, 0.1135, -0.02484, 0.0
    0x2c15ae00, 0x1babac42, 0x20d2a616, 0xa935, 0x3732b432, 0x9d43abb7, 0x2f449daf, 0xa65c,
    // 0.269, -0.3213, -0.1987, -0.0358, -0.085, -0.03137, 0.11505, 0.0, -0.1327, 0.04025, -0.09106, 0.09894, -0.06964, -0.02907, 0.0432, 0.0
    0xb524344e, 0xa895b25c, 0xa804ad71, 0x2f5d, 0x2927b03f, 0x2e55add4, 0xa771ac75, 0x2988,
    // 0.0345, 0.2288, -0.4092, 0.02322, -0.1076, -0.02676, 0.07025, 0.0, -0.0903, 0.2349, -0.1726, 0.02858, 0.001643, -0.05038, 0.03778, 0.0
    0x3352286a, 0x25f2b68c, 0xa6daaee3, 0x2c7f, 0x3384adc7, 0x2751b186, 0xaa7316bb, 0x28d6,
    // -0.2485, 0.2383, -0.3518, -0.10394, -0.126, 0.108, 0.1425, 0.0, 0.0332, 0.2241, -0.263, 0.03445, -0.05585, -0.03102, -0.01938, 0.0
    0x33a0b3f4, 0xaea7b5a1, 0x2ee9b008, 0x308f, 0x332c2840, 0x2869b435, 0xa7f1ab26, 0xa4f6,
    // -0.298, 0.05124, 0.3503, -0.06396, -0.06018, 0.0659, -0.01857, 0.0, 0.471, 0.04218, 0.1162, -0.1382, 0.0995, -0.005585, -0.0466, 0.0
    0x2a8fb4c5, 0xac18359b, 0x2c38abb4, 0xa4c1, 0x29663789, 0xb06c2f70, 0x9db82e5e, 0xa9f7,
    // -0.3748, 0.1963, 0.1963, 0.0883, -0.2817, 0.2524, 0.1685, 0.0, -0.08417, 0.01141, 0.2131, 0.1986, -0.1451, -0.04077, 0.06052, 0.0
    0x3248b5ff, 0x2da73248, 0x340ab482, 0x3164, 0x21d8ad63, 0x325b32d2, 0xa938b0a5, 0x2bbf,
    // 0.1786, -0.11554, -0.9507, 0.1342, 0.2155, -0.1571, -0.1305, 0.0, 0.2676, -0.087, -0.6914, -0.10516, 0.1561, -0.1669, 0.1083, 0.0
    0xaf6531b7, 0x304bbb9b, 0xb10732e5, 0xb02d, 0xad913448, 0xaebbb988, 0xb15730ff, 0x2eee,
    // 0.0467, -0.1859, -0.847, -0.008, -0.03044, -0.0322, 0.01724, 0.0, 0.04492, -0.0928, -0.6147, -0.1338, 0.07776, -0.02412, 0.245, 0.0
    0xb1f329fa, 0xa019bac7, 0xa81fa7cb, 0x246a, 0xadf029c0, 0xb048b8eb, 0xa62d2cfa, 0x33d7,
    // -0.256, 0.1327, -0.2399, 0.1992, 0.002281, 0.06354, -0.1913, 0.0, -0.0985, 0.3054, -0.1934, -0.1968, 0.07605, -0.1744, -0.02495, 0.0
    0x303fb419, 0x3260b3ad, 0x2c1118ac, 0xb21f, 0x34e3ae4e, 0xb24cb230, 0xb1952cde, 0xa663,
    // -0.1393, 0.1107, -0.191, 0.0818, 0.05438, 0.6577, -0.3535, 0.0, -0.1404, 0.151, -0.1392, -0.2727, 0.2283, 0.4006, -0.328, 0.0
    0x2f16b075, 0x2d3cb21d, 0x39432af6, 0xb5a8, 0x30d5b07e, 0xb45db074, 0x3669334e, 0xb53f,
    // -0.1218, 0.1793, 0.2542, -0.2112, 0.414, -0.02812, -0.02753, 0.0, -0.1652, 0.1686, 0.2708, -0.1648, 0.328, -0.035, -0.11865, 0.0
    0x31bdafcc, 0xb2c23411, 0xa73336a0, 0xa70c, 0x3165b149, 0xb1463455, 0xa87b353f, 0xaf98,
    // -0.1705, 0.1987, 0.3428, -0.2189, 0.2686, -0.1708, 0.07153, 0.0, -0.1876, 0.1558, 0.2318, -0.1031, 0.2673, -0.08844, 0.11066, 0.0
    0x325cb175, 0xb301357c, 0xb177344c, 0x2c94, 0x30fcb201, 0xae99336b, 0xada93447, 0x2f15,
    // 0.1105, -0.1952, 0.448, 0.18, -0.03387, -0.0986, -0.0603, 0.0, 0.195, -0.2113, 0.4258, -0.05774, 0.1012, 0.1576, 0.11224, 0.0
    0xb23f2f12, 0x31c3372b, 0xae4fa856, 0xabb8, 0xb2c3323d, 0xab6436d0, 0x310b2e7a, 0x2f2f,
    // 0.2744, -0.1747, 0.269, -0.356, 0.1279, 0.1306, -0.02205, 0.0, 0.2217, -0.1842, 0.383, 0.127, 0.1373, -0.134, -0.1946, 0.0
    0xb1973464, 0xb5b2344e, 0x302e3018, 0xa5a5, 0xb1e53318, 0x30103621, 0xb04a3065, 0xb23a,
    // 0.0807, -0.03906, -0.282, -0.2462, -0.0874, 0.2202, 0.10974, 0.0, 0.05292, -0.06366, -0.2654, -0.1521, -0.09814, 0.343, 0.0345, 0.0
    0xa9002d2a, 0xb3e1b483, 0x330cad98, 0x2f06, 0xac132ac6, 0xb0deb43f, 0x357dae48, 0x286a,
    // 0.04044, -0.0342, -0.2544, -0.2354, 0.0574, 0.05927, 0.1482, 0.0, 0.04172, -0.05533, -0.3096, -0.12006, -0.03586, 0.1298, 0.1887, 0.0
    0xa861292d, 0xb388b412, 0x2b962b59, 0x30be, 0xab152957, 0xafafb4f4, 0x3027a897, 0x320a,
    // -0.2041, 0.1099, -0.00527, -0.0939, 0.05637, 0.0825, -0.0973, 0.0, -0.3855, -0.02226, 0.0765, -0.2866, 0.0841, -0.014015, 0.1829, 0.0
    0x2f09b288, 0xae029d65, 0x2d482b37, 0xae3a, 0xa5b3b62b, 0xb4962ce5, 0xa32d2d62, 0x31da,
    // 0.1354, 0.3582, -0.132, 0.107, -0.1993, 0.007084, -0.1868, 0.0, 0.0525, 0.1164, -0.0346, 0.1134, -0.02051, -0.11237, 0.1642, 0.0
    0x35bb3055, 0x2ed9b039, 0x1f41b261, 0xb1fa, 0x2f732ab8, 0x2f42a86e, 0xaf31a540, 0x3141,
    // 0.05667, 0.06244, -0.5127, 0.06, 0.11316, 0.0909, -0.1782, 0.0, 0.05295, 0.01192, -0.5273, 0.2361, 0.0719, 0.3333, -0.277, 0.0
    0x2bfe2b41, 0x2baeb81a, 0x2dd12f3e, 0xb1b4, 0x221a2ac7, 0x338eb838, 0x35552c9a, 0xb46f,
    // -0.0637, 0.0641, -0.5806, 0.1697, 0.1877, -0.2062, -0.1908, 0.0, -0.03415, 0.04047, -0.6265, 0.2937, 0.02776, -0.04166, -0.2336, 0.0
    0x2c1aac14, 0x316eb8a5, 0xb2993202, 0xb21b, 0x292ea85f, 0x34b3b903, 0xa955271b, 0xb37a,
};
static const uint32_t weights_performance[256] = {
    // 0.278, 0.11414, -0.1307, 0.00789, -0.0999, 0.00652, 0.0005727, 0.0, 0.3293, 0.04, -0.0829, -0.06094, -0.0712, 0.0889, 0.03278, 0.0
    0x2f4e3473, 0x200ab02f, 0x1eadae65, 0x10b1, 0x291f3545, 0xabcdad4e, 0x2db1ac8f, 0x2832,
    // -0.222, -0.11945, -0.1675, 0.10034, 0.04697, -0.02281, -0.1938, 0.0, -0.1963, -0.2754, -0.1103, 0.03696, 0.04355, 0.1566, -0.1217, 0.0
    0xafa5b31b, 0x2e6cb15c, 0xa5d72a03, 0xb234, 0xb468b248, 0x28bbaf0f, 0x31032993, 0xafca,
    // -0.03787, -0.2693, -0.662, 0.02242, -0.1184, -0.1597, 0.08, 0.0, 0.0734, -0.0891, -0.6333, 0.1538, -0.1138, 0.03644, -0.07324, 0.0
    0xb44fa8d9, 0x25bdb94c, 0xb11caf94, 0x2d1f, 0xadb42cb3, 0x30ecb911, 0x28aaaf48, 0xacb0,
    // 0.06714, -0.03903, -0.622, -0.10254, 0.1011, 0.07184, 0.0777, 0.0, 0.1896, 0.0924, -0.4448, -0.0443, 0.077, 0.301, -0.162, 0.0
    0xa8ff2c4c, 0xae90b8fa, 0x2c992e78, 0x2cf9, 0x2dea3211, 0xa9acb71e, 0x34d12cee, 0xb12f,
    // -0.06824, 0.162, 0.7026, -0.06537, -0.10834, -0.0802, 0.1495, 0.0, -0.1261, 0.05026, 0.589, 0.03717, 0.0816, -0.11115, -0.06757, 0.0
    0x312fac5e, 0xac2f399f, 0xad22aeef, 0x30c9, 0x2a6fb009, 0x28c238b6, 0xaf1d2d39, 0xac53,
    // -0.0961, 0.1554, 0.7754, -0.159, 0.04816, -0.009445, 0.1771, 0.0, -0.2162, 0.04724, 0.6626, -0.06506, 0.1506, -0.1335, -0.1675, 0.0
    0x30f9ae27, 0xb1173a34, 0xa0d62a2a, 0x31ab, 0x2a0cb2eb, 0xac2a394d, 0xb04630d2, 0xb15c,
    // 0.3262, -0.3704, 0.4329, 0.1914, -0.08374, -0.0752, -0.1223, 0.0, 0.0791, 0.06604, 0.4795, 0.0715, 0.1783, -0.08765, 0.09454, 0.0
    0xb5ed3538, 0x322036ed, 0xacd0ad5c, 0xafd4, 0x2c3a2d10, 0x2c9337ac, 0xad9c31b5, 0x2e0d,
    // 0.02483, 0.02966, 0.5605, -0.108, -0.0669, 0.0688, 0.010254, 0.0, -0.449, 0.3547, 0.654, -0.1642, 0.06824, -0.02838, 0.0843, 0.0
    0x2798265b, 0xaee9387c, 0x2c67ac48, 0x2140, 0x35adb72f, 0xb141393b, 0xa7442c5e, 0x2d65,
    // 0.309, -0.02872, -0.2927, -0.11444, 0.08527, -0.002712, -0.03607, 0.0, -0.0226, -0.0315, -0.3022, 0.03784, -0.10767, -0.001668, -0.119, 0.0
    0xa75a34f2, 0xaf53b4af, 0x998e2d75, 0xa89e, 0xa808a5c9, 0x28d8b4d6, 0x96d5aee4, 0xaf9e,
    // 0.0361, 0.02069, -0.2449, 0.0344, 0.098, -0.013824, 0.0544, 0.0, -0.3997, 0.0767, -0.1799, 0.1272, 0.02773, 0.01459, 0.0543, 0.0
    0x254c289f, 0x2867b3d6, 0xa3142e46, 0x2af7, 0x2ce9b665, 0x3012b1c2, 0x23782719, 0x2af3,
    // 0.2494, -0.01689, -0.3506, -0.0225, -0.0899, 0.1076, 0.11127, 0.0, 0.1998, -0.07776, -0.424, -0.0939, -0.02425, 0.1434, 0.02159, 0.0
    0xa45333fb, 0xa5c3b59c, 0x2ee3adc1, 0x2f1f, 0xacfa3265, 0xae02b6c9, 0x3097a635, 0x2587,
    // 0.1372, -0.04605, -0.4675, 0.1108, -0.1079, 0.04877, 0.1449, 0.0, 0.1394, -0.0342, -0.3772, 0.01872, 0.00775, 0.02016, 0.05887, 0.0
    0xa9e53064, 0x2f17b77b, 0x2a3eaee8, 0x30a3, 0xa8613076, 0x24cbb609, 0x25291ff0, 0x2b89,
    // -0.2068, 0.2161, -0.3274, 0.2379, 0.0676, 0.2081, -0.43, 0.0, -0.1754, 0.2186, -0.2507, 0.2119, 0.1399, 0.0584, -0.4385, 0.0
    0x32eab29e, 0x339db53d, 0x32a92c54, 0xb6e1, 0x32ffb19d, 0x32c8b403, 0x2b7a307a, 0xb704,
    // -0.127, 0.1857, -0.3796, 0.211, 0.11096, 0.2034, -0.4111, 0.0, -0.0935, 0.213, -0.306, 0.1643, 0.2595, 0.0875, -0.3018, 0.0
    0x31f1b010, 0x32c1b613, 0x32822f1a, 0xb694, 0x32d1adfc, 0x3142b4e5, 0x2d9a3427, 0xb4d4,
    // 0.1553, -0.1732, -0.3892, 0.0848, 0.159, -0.2102, -0.1742, 0.0, 0.13, -0.12177, -0.278, 0.0018015, 0.1652, -0.2092, -0.1103, 0.0
    0xb18b30f8, 0x2d6db63a, 0xb2ba3117, 0xb193, 0xafcb3029, 0x1761b473, 0xb2b23149, 0xaf0f,
    // 0.216, -0.1675, -0.392, 0.03195, 0.2656, -0.2852, 0.03625, 0.0, 0.2314, -0.1486, -0.2338, 0.02602, 0.2468, -0.2598, 0.1108, 0.0
    0xb15c32e9, 0x2817b646, 0xb4903440, 0x28a4, 0xb0c13368, 0x26a9b37b, 0xb42833e6, 0x2f17,
    // -0.226, -0.1584, -0.3335, -0.08466, 0.1263, 0.0338, -0.04437, 0.0, 0.3545, -0.02823, -0.248, -0.008446, 0.03464, -0.0684, -0.05734, 0.0
    0xb112b33b, 0xad6bb556, 0x2854300b, 0xa9ae, 0xa73a35ac, 0xa053b3f0, 0xac61286f, 0xab57,
    // -0.4111, 0.0997, -0.1968, -0.01932, 0.02362, 0.03137, 0.05194, 0.0, 0.1302, 0.1837, -0.2776, 0.06946, -0.0242, -0.1405, 0.0625, 0.0
    0x2e61b694, 0xa4f2b24c, 0x2804260c, 0x2aa6, 0x31e1302b, 0x2c72b471, 0xb07fa632, 0x2c00,
    // 0.02487, -0.1714, -0.1981, 0.096, 0.0904, 0.0409, 0.076, 0.0, 0.002506, -0.1309, -0.168, -0.06158, 0.01146, 0.138, -0.09033, 0.0
    0xb17c265e, 0x2e25b257, 0x293c2dc9, 0x2cdd, 0xb0301922, 0xabe2b160, 0x306a21de, 0xadc8,
    // 0.01151, -0.1012, -0.2261, 0.10187, 0.002346, -0.09686, -0.00389, 0.0, -0.03513, -0.0992, -0.2328, -0.08685, -0.01703, 0.0188, -0.04794, 0.0
    0xae7a21e5, 0x2e85b33c, 0xae3318ce, 0x9bf7, 0xae59a87f, 0xad8fb373, 0x24d0a45c, 0xaa23,
    // -0.252, 0.2517, -0.4543, 0.1826, -0.0821, -0.04205, -0.05417, 0.0, -0.1654, 0.2028, -0.382, 0.0682, -0.183, 0.0684, -0.05457, 0.0
    0x3407b408, 0x31d8b745, 0xa962ad41, 0xaaef, 0x327db14b, 0x2c5db61d, 0x2c61b1db, 0xaafc,
    // -0.2094, 0.1843, -0.535, 0.1083, -0.2274, -0.01134, 0.1774, 0.0, -0.2383, 0.1099, -0.533, -0.08, -0.251, 0.07697, 0.1984, 0.0
    0x31e6b2b3, 0x2eeeb848, 0xa1ceb347, 0x31ad, 0x2f09b3a0, 0xad1fb844, 0x2cedb404, 0x3259,
    // -0.02003, 0.2344, -0.3333, 0.10065, 0.3748, -0.1892, 0.1716, 0.0, -0.03363, 0.1512, -0.3577, 0.0811, 0.0875, -0.094, -0.03047, 0.0
    0x3380a521, 0x2e71b555, 0xb20e35ff, 0x317e, 0x30d7a84e, 0x2d31b5b9, 0xae042d9a, 0xa7cd,
    // -0.05646, 0.1573, -0.51, -0.0807, 0.1454, -0.2278, -0.0518, 0.0, -0.12036, 0.1171, -0.4377, -0.1554, -0.0968, -0.0256, -0.1382, 0.0
    0x3109ab3a, 0xad2ab814, 0xb34a30a7, 0xaaa1, 0x2f7fafb4, 0xb0f9b701, 0xa68eae32, 0xb06c,
    // -0.01419, -0.06726, 1.004, 0.01883, 0.03305, -0.005318, 0.02458, 0.0, 0.03793, -0.01797, 0.9365, 0.01637, -0.0975, 0.06183, -0.06946, 0.0
    0xac4ea344, 0x24d23c04, 0x9d72283b, 0x264b, 0xa49a28db, 0x24313b7e, 0x2beaae3d, 0xac72,
    // 0.003275, -0.01674, 1.021, 0.0823, 0.01414, -0.04947, 0.003874, 0.0, 0.0898, 0.08685, 0.959, -0.006554, -0.04465, 0.1016, 0.0597, 0.0
    0xa4491ab5, 0x2d443c16, 0xaa55233d, 0x1bef, 0x2d8f2dbf, 0x9eb63bac, 0x2e81a9b7, 0x2ba4,
    // 0.001593, 0.03687, -0.05646, 0.2812, -0.01782, -0.1715, 0.0789, 0.0, 0.01094, 0.00935, 0.0315, 0.3665, -0.0745, -0.1617, 0.0847, 0.0
    0x28b81686, 0x3480ab3a, 0xb17da490, 0x2d0d, 0x20ca219a, 0x35dd2808, 0xb12dacc5, 0x2d6c,
    // -0.03256, -0.03302, 0.005943, 0.2717, -0.045, -0.0522, -0.002676, 0.0, -0.01324, -0.0608, 0.0674, 0.3596, 0.05432, -0.03146, 0.0541, 0.0
    0xa83aa82b, 0x34591e16, 0xaaaea9c3, 0x997b, 0xabc8a2c7, 0x35c12c50, 0xa8072af4, 0x2aed,
    // -0.1373, 0.0373, -0.2119, -0.02821, -0.05905, -0.02556, 0.02437, 0.0, -0.101, 0.1367, -0.1761, -0.09106, -0.04004, 0.02089, 0.05362, 0.0
    0x28c6b065, 0xa739b2c8, 0xa68bab8f, 0x263d, 0x3060ae77, 0xadd4b1a3, 0x2559a920, 0x2add,
    // -0.1478, 0.1025, -0.1968, 0.1259, 0.05725, -0.1251, -0.07623, 0.0, -0.0851, 0.2585, -0.0968, 0.0855, 0.05927, -0.05426, -0.02702, 0.0
    0x2e8fb0bb, 0x3007b24c, 0xb0012b54, 0xace1, 0x3423ad72, 0x2d79ae32, 0xaaf22b96, 0xa6eb,
    // 0.263, -0.2352, -0.2908, 0.265, -0.1647, 0.073, -0.2179, 0.0, 0.2063, -0.1437, -0.2896, 0.2642, -0.2234, 0.02736, -0.2559, 0.0
    0xb3873435, 0x343db4a7, 0x2cacb145, 0xb2f9, 0xb099329a, 0x343ab4a2, 0x2701b326, 0xb418,
    // 0.1914, -0.11066, -0.3281, 0.1989, -0.239, 0.1033, -0.2905, 0.0, 0.1544, -0.09644, -0.21, 0.1141, -0.252, 0.01265, -0.3186, 0.0
    0xaf153220, 0x325db540, 0x2e9cb3a6, 0xb4a6, 0xae2c30f1, 0x2f4db2b8, 0x227ab408, 0xb519,
};
static const uint32_t weights_drs[256] = {
    // -0.1238, 0.1241, 0.8296, -0.2001, -0.32, -0.0798, -0.0194, 0.0, -0.06107, 0.11285, 0.8213, -0.1229, 0.0745, -0.0054, -0.03102, 0.0
    0x2ff1afec, 0xb2673aa3, 0xad1bb51f, 0xa4f7, 0x2f39abd1, 0xafde3a92, 0x9d882cc5, 0xa7f1,
    // -0.2703, 0.1512, 0.9873, -0.0005536, -0.04968, -0.08966, 0.07043, 0.0, -0.1477, 0.1962, 0.933, -0.0915, -0.2388, -0.0557, -0.02872, 0.0
    0x30d7b453, 0x90893be6, 0xadbdaa5c, 0x2c82, 0x3247b0ba, 0xaddb3b77, 0xab21b3a4, 0xa75a,
    // 0.1523, -0.2234, -0.5005, -0.11426, -0.2314, -0.3503, 0.3767, 0.0, 0.1782, -0.04944, -0.4717, -0.1327, 0.04272, -0.2119, 0.2517, 0.0
    0xb32630e0, 0xaf50b801, 0xb59bb368, 0x3607, 0xaa5431b4, 0xb03fb78c, 0xb2c82978, 0x3407,
    // 0.2031, -0.11414, -0.6187, 0.012276, 0.3376, -0.1768, -0.05493, 0.0, 0.2174, 0.06238, -0.666, -0.1904, 0.2377, -0.1161, 0.02782, 0.0
    0xaf4e3280, 0x2249b8f3, 0xb1a83567, 0xab08, 0x2bfc32f5, 0xb218b954, 0xaf6e339b, 0x271f,
    // -0.1567, 0.2454, -0.5825, 0.0482, -0.2002, 0.1139, 0.1781, 0.0, -0.239, 0.2416, -0.5024, 0.1164, -0.2766, -0.0779, 0.1681, 0.0
    0x33dab104, 0x2a2bb8a9, 0x2f4ab268, 0x31b3, 0x33bbb3a6, 0x2f73b805, 0xacfcb46d, 0x3161,
    // -0.252, 0.1259, -0.7173, -0.0949, 0.02153, -0.004524, 0.01275, 0.0, -0.2837, 0.09076, -0.7, 0.03014, 0.0618, -0.001638, 0.00947, 0.0
    0x3007b408, 0xae13b9bd, 0x9ca22583, 0x2287, 0x2dcfb48a, 0x27b7b99a, 0x96b62be9, 0x20d9,
    // -0.1344, 0.1615, -0.7383, -0.07074, 0.1311, -0.1449, 0.1207, 0.0, -0.2603, 0.1515, -0.6934, -0.05792, 0.2717, -0.2408, 0.1375, 0.0
    0x312bb04d, 0xac87b9e8, 0xb0a33032, 0x2fba, 0x30d9b42a, 0xab6ab98c, 0xb3b53459, 0x3066,
    // 0.04477, 0.1868, -0.7783, 0.1323, -0.2236, -0.09344, 0.3171, 0.0, -0.0365, 0.2307, -0.726, 0.0007925, 0.02638, -0.4175, 0.2386, 0.0
    0x31fa29bb, 0x303cba3a, 0xadfbb328, 0x3513, 0x3362a8ac, 0x127eb9cf, 0xb6ae26c1, 0x33a3,
    // -0.05667, 0.1015, -0.067, -0.002323, -0.10724, -0.00961, 0.0851, 0.0, 0.373, -0.08795, -0.11847, 0.009735, 0.2625, -0.1711, 0.07135, 0.0
    0x2e7fab41, 0x98c2ac4a, 0xa0ecaedd, 0x2d72, 0xada135f8, 0x20fcaf95, 0xb17a3433, 0x2c91,
    // -0.1862, -0.05765, -0.1351, 0.1301, 0.04935, 0.05524, -0.03029, 0.0, 0.162, -0.288, -0.05743, -0.1198, -0.00895, -0.09845, -0.05576, 0.0
    0xab61b1f5, 0x302ab053, 0x2b122a51, 0xa7c1, 0xb49c312f, 0xafabab5a, 0xae4da095, 0xab23,
    // -0.03925, 0.1377, 0.8286, 0.1428, -0.01155, -0.0791, 0.1035, 0.0, 0.01176, 0.0858, 0.739, -0.02617, -0.1307, -0.10925, 0.1097, 0.0
    0x3068a906, 0x30923aa1, 0xad10a1ea, 0x2ea0, 0x2d7e2205, 0xa6b339e9, 0xaefeb02f, 0x2f05,
    // 0.014755, 0.0429, 0.87, 0.123, -0.08575, 0.02756, -0.02983, 0.0, 0.0265, -0.02574, 0.8735, 0.03387, 0.03687, 0.0491, -0.09863, 0.0
    0x297e238e, 0x2fdf3af6, 0x270ead7d, 0xa7a3, 0xa69726c9, 0x28563afd, 0x2a4928b8, 0xae50,
    // -0.00764, 0.2278, -0.6, -0.05832, 0.05664, 0.1953, -0.2554, 0.0, 0.007576, 0.1655, -0.6006, -0.2903, 0.08374, 0.2175, -0.2178, 0.0
    0x334a9fd3, 0xab77b8cd, 0x32402b40, 0xb416, 0x314c1fc2, 0xb4a5b8ce, 0x32f62d5c, 0xb2f8,
    // 0.1741, -0.002281, -0.7383, 0.08325, 7.67e-05, 0.0503, -0.268, 0.0, 0.0886, -0.1239, -0.808, 0.06824, -0.1892, 0.3137, -0.3171, 0.0
    0x98ac3192, 0x2d54b9e8, 0x2a700507, 0xb44a, 0xafee2dac, 0x2c5eba77, 0x3505b20e, 0xb513,
    // -0.0663, 0.1149, 0.1826, 0.1389, -0.1072, 0.05774, -0.12115, 0.0, 0.013, 0.1697, 0.193, 0.2338, 0.1322, 0.09985, -0.17, 0.0
    0x2f5bac3e, 0x307231d8, 0x2b64aedc, 0xafc1, 0x316e22a8, 0x337b322d, 0x2e64303b, 0xb171,
    // -0.1976, 0.1871, 0.2303, 0.05914, 0.02007, 0.0557, -0.1151, 0.0, -0.1174, 0.2656, 0.2515, 0.161, 0.06934, -0.0001348, -0.06757, 0.0
    0x31fdb253, 0x2b92335f, 0x2b212523, 0xaf5e, 0x3440af83, 0x31273406, 0x886b2c70, 0xac53,
    // -0.05118, 0.1332, 0.1255, -0.3284, 0.1384, 0.2081, 0.1555, 0.0, -0.044, 0.10895, 0.1992, -0.3354, 0.1234, 0.11536, 0.1221, 0.0
    0x3043aa8d, 0xb5413004, 0x32a9306e, 0x30fa, 0x2ef9a9a2, 0xb55e3260, 0x2f622fe6, 0x2fd0,
    // -0.07043, 0.0777, 0.1147, -0.3032, -0.00875, 0.11487, 0.2205, 0.0, -0.07904, 0.0559, 0.2211, -0.2659, 0.1554, 0.1904, 0.226, 0.0
    0x2cf9ac82, 0xb4da2f57, 0x2f5aa07b, 0x330e, 0x2b28ad0f, 0xb4413313, 0x321830f9, 0x333b,
    // 0.0258, -0.423, -0.159, -0.0857, 0.1852, 0.03787, -0.02968, 0.0, 0.4233, 0.04626, -0.1531, -0.1447, 0.01123, -0.01659, 0.0494, 0.0
    0xb6c5269b, 0xad7cb117, 0x28d931ed, 0xa799, 0x29ec36c6, 0xb0a1b0e6, 0xa43f21c0, 0x2a53,
    // -0.1721, -0.1708, -0.1888, 0.05618, -0.01906, 0.05865, 0.01688, 0.0, -0.01148, 0.2058, -0.2098, 0.06616, 0.1389, -0.02113, -0.0837, 0.0
    0xb177b182, 0x2b31b20b, 0x2b82a4e1, 0x2452, 0x3296a1e1, 0x2c3cb2b7, 0xa5693072, 0xad5b,
    // -0.432, 0.10785, -0.3567, 0.1007, 0.09174, -0.0968, 0.00455, 0.0, -0.00983, 0.0697, -0.4421, -0.01052, -0.1707, 0.04382, -0.03345, 0.0
    0x2ee7b6e9, 0x2e72b5b5, 0xae322ddf, 0x1ca9, 0x2c76a108, 0xa163b713, 0x299cb176, 0xa848,
    // -0.3386, 0.2217, -0.4177, 0.03128, -0.0337, 0.0991, -0.04758, 0.0, 0.0743, 0.3176, -0.413, -0.1666, -0.1866, 0.2013, -0.04425, 0.0
    0x3318b56b, 0x2801b6af, 0x2e58a850, 0xaa17, 0x35152cc1, 0xb155b69c, 0x3271b1f9, 0xa9aa,
    // -0.07196, 0.229, 0.2708, -0.004253, 0.4412, -0.1875, -0.255, 0.0, -0.1667, 0.1256, 0.148, 0.1473, 0.2576, -0.1805, -0.1321, 0.0
    0x3354ac9b, 0x9c5b3455, 0xb200370f, 0xb414, 0x3005b156, 0x30b730bc, 0xb1c7341f, 0xb03a,
    // -0.1315, 0.1953, 0.2362, 0.03824, 0.4255, -0.208, -0.2268, 0.0, -0.2732, 0.04822, 0.02739, -0.02817, 0.4019, -0.3547, -0.3167, 0.0
    0x3240b035, 0x28e5338f, 0xb2a836cf, 0xb342, 0x2a2cb45f, 0xa7362703, 0xb5ad366e, 0xb511,
    // -0.0997, -0.03424, -0.1484, 0.0439, -0.02074, -0.1635, 0.1969, 0.0, 0.2722, -0.02452, -0.1976, -0.0957, 0.1632, 0.02466, -0.07166, 0.0
    0xa862ae61, 0x299fb0c0, 0xb13ba54f, 0x324d, 0xa647345b, 0xae20b253, 0x26503139, 0xac96,
    // -0.0842, -0.06213, -0.2009, -0.046, -0.1698, -0.1637, 0.1643, 0.0, 0.07166, -0.1796, -0.277, 0.0533, 0.35, -0.03824, -0.0543, 0.0
    0xabf4ad64, 0xa9e3b26e, 0xb13db16f, 0x3142, 0xb1bf2c96, 0x2ad3b46f, 0xa8e5359a, 0xaaf3,
    // 0.2512, -0.2039, -0.31, -0.01852, -0.1316, 0.1755, 0.00891, 0.0, 0.2812, -0.1833, -0.2842, 0.269, -0.09796, 0.0269, -0.07184, 0.0
    0xb2863405, 0xa4beb4f6, 0x319eb036, 0x2090, 0xb1de3480, 0x344eb48c, 0x26e3ae45, 0xac99,
    // 0.2744, -0.125, -0.3367, -0.2393, -0.0544, 0.1179, 0.1498, 0.0, 0.2386, -0.1024, -0.3403, -0.21, 0.006413, 0.0299, -0.05743, 0.0
    0xb0003464, 0xb3a8b563, 0x2f8caaf7, 0x30cb, 0xae8e33a3, 0xb2b8b572, 0x27a81e91, 0xab5a,
    // -0.3213, 0.001846, 0.2283, -0.01168, -0.05563, 0.05, -0.0187, 0.0, -0.3708, 0.0612, 0.2411, 0.04, 0.04712, 0.004887, -0.02792, 0.0
    0x1790b524, 0xa1fb334e, 0x2a66ab1f, 0xa4ca, 0x2bd5b5ef, 0x291f33b7, 0x1d012a08, 0xa726,
    // 0.2852, -0.03714, 0.155, -0.005375, 0.04077, 0.02194, -0.0358, 0.0, 0.3025, 0.002779, 0.1329, 0.01376, 0.046, -0.00995, -0.06256, 0.0
    0xa8c13490, 0x9d8130f6, 0x259e2938, 0xa895, 0x19b134d7, 0x230c3041, 0xa11829e3, 0xac01,
    // -0.0903, 0.04688, 0.1318, -0.0713, 0.103, 0.1686, -0.1315, 0.0, 0.2344, 0.01819, 0.04712, 0.1523, -0.2915, 0.0162, 0.0704, 0.0
    0x2a00adc7, 0xac903038, 0x31652e98, 0xb035, 0x24a83380, 0x30e02a08, 0x2426b4aa, 0x2c81,
    // -0.1055, -0.03156, 0.003304, -0.2285, 0.0662, -0.1268, 0.0807, 0.0, 0.1997, -0.06216, 0.04172, 0.1511, -0.03815, -0.1882, 0.221, 0.0
    0xa80aaec1, 0xb3501ac4, 0xb00f2c3d, 0x2d2a, 0xabf53264, 0x30d62957, 0xb206a8e2, 0x3312,
};
static const uint32_t weights_ultraperf[256] = {
    // 0.1537, -0.1125, -0.1558, 0.0194, -0.06354, 0.0769, -0.03766, 0.0, 0.4497, 0.0829, -0.1101, -0.08093, -0.007233, -0.01619, 0.00691, 0.0
    0xaf3330eb, 0x24f7b0fc, 0x2cecac11, 0xa8d2, 0x2d4e3732, 0xad2eaf0c, 0xa4259f68, 0x1f13,
    // -0.408, -0.1045, -0.221, 0.1215, -0.006416, -0.02164, -0.1295, 0.0, -0.3145, -0.02995, -0.04388, 0.077, 0.0948, -0.06946, -0.08044, 0.0
    0xaeb0b687, 0x2fc7b312, 0xa58a9e92, 0xb025, 0xa7abb508, 0x2ceea99e, 0xac722e11, 0xad26,
    // 0.09106, -0.2185, -0.588, -0.00816, -0.1777, 0.1622, -0.1968, 0.0, 0.0537, -0.1387, -0.5933, 0.04684, 0.03098, 0.02483, -0.005234, 0.0
    0xb2fe2dd4, 0xa02eb8b4, 0x3131b1b0, 0xb24c, 0xb0702ae0, 0x29ffb8bf, 0x265b27ee, 0x9d5c,
    // 0.2295, -0.08887, -0.4058, 0.11786, 0.03314, -0.0928, -0.08795, 0.0, 0.2283, -0.1115, -0.409, 0.1323, 0.10547, -0.0654, -0.001252, 0.0
    0xadb03358, 0x2f8bb67e, 0xadf0283e, 0xada1, 0xaf23334e, 0x303cb68b, 0xac302ec0, 0x9521,
    // -0.2024, 0.09094, 0.553, -0.010414, -0.01047, 0.02092, -0.08185, 0.0, -0.07324, 0.09406, 0.523, 0.1384, 0.10583, -0.00947, -0.04947, 0.0
    0x2dd2b27a, 0xa155386d, 0x255ba15c, 0xad3d, 0x2e05acb0, 0x306e382f, 0xa0d92ec6, 0xaa55,
    // -0.2073, 0.1921, 0.349, -0.131, 0.1431, -0.1343, 0.1289, 0.0, -0.2393, 0.2175, 0.4868, -0.11426, 0.0422, -0.10675, 0.08606, 0.0
    0x3226b2a2, 0xb0313596, 0xb04c3094, 0x3020, 0x32f6b3a8, 0xaf5037ca, 0xaed52967, 0x2d82,
    // 0.5474, -0.0818, -0.04407, -0.031, -0.04855, 0.00623, 0.01417, 0.0, -0.111, -0.0283, -0.08496, -0.00932, -0.018, 0.02707, 0.002443, 0.0
    0xad3c3861, 0xa7f0a9a4, 0x1e61aa37, 0x2341, 0xa73faf1b, 0xa0c6ad70, 0x26eea49c, 0x1901,
    // 0.1156, 0.0651, 0.1132, -0.007797, 0.00903, -0.02579, -0.001712, 0.0, -0.6504, 0.0994, 0.1711, 0.02489, 0.05026, -0.02657, 0.00949, 0.0
    0x2c2b2f66, 0x9ffc2f3f, 0xa69a20a0, 0x9703, 0x2e5db934, 0x265f317a, 0xa6cd2a6f, 0x20dc,
    // 0.2269, -0.1854, -0.03424, -0.00631, 0.02754, -0.1442, -0.1043, 0.0, 0.2158, -0.01434, 0.02397, 0.0703, 0.077, -0.07916, -0.02397, 0.0
    0xb1ef3343, 0x9e76a862, 0xb09d270d, 0xaead, 0xa35832e8, 0x2c802623, 0xad112cee, 0xa623,
    // -0.04114, -0.07983, 0.02995, -0.065, 0.00347, 0.0633, 0.05487, 0.0, 0.0373, 0.10114, 0.01875, 0.0374, -0.01952, 0.1957, 0.08527, 0.0
    0xad1ca944, 0xac2927ab, 0x2c0d1b1b, 0x2b06, 0x2e7928c6, 0x28ca24cd, 0x3243a4ff, 0x2d75,
    // 0.2206, -0.11035, 0.1774, -0.07025, -0.1416, 0.1853, 0.0952, 0.0, 0.2805, -0.01337, 0.211, -0.0846, -0.1635, 0.2233, 0.0298, 0.0
    0xaf10330f, 0xac7f31ad, 0x31eeb088, 0x2e18, 0xa2d8347d, 0xad6a32c1, 0x3325b13b, 0x27a1,
    // 0.1483, 0.0557, 0.2593, 9.57e-05, 0.04922, -0.0567, -0.03412, 0.0, 0.2869, 0.09314, 0.1584, 0.010155, -0.09485, -0.009056, -0.12036, 0.0
    0x2b2130bf, 0x6463426, 0xab422a4d, 0xa85e, 0x2df63497, 0x21333112, 0xa0a3ae12, 0xafb4,
    // -0.0584, 0.1355, -0.593, 0.2113, 0.1085, -0.03235, -0.3213, 0.0, -0.05386, 0.0761, -0.6, 0.2556, 0.03516, 0.07654, -0.378, 0.0
    0x3056ab7a, 0x32c3b8be, 0xa8242ef2, 0xb524, 0x2cdfaae5, 0x3417b8cd, 0x2ce62880, 0xb60c,
    // -0.0398, 0.0662, -0.5317, 0.2273, -0.01125, -0.02553, -0.2408, 0.0, -0.0953, -0.01121, -0.4983, 0.208, -0.11957, 0.1307, -0.3398, 0.0
    0x2c3da918, 0x3346b841, 0xa689a1c3, 0xb3b5, 0xa1bdae19, 0x32a8b7f9, 0x302fafa7, 0xb570,
    // 0.2115, -0.0527, -0.1477, -0.01595, 0.2339, -0.509, 0.1631, 0.0, 0.1582, -0.1455, -0.09906, 0.04315, 0.2103, -0.406, 0.0008388, 0.0
    0xaabf32c5, 0xa415b0ba, 0xb812337c, 0x3138, 0xb0a83110, 0x2986ae57, 0xb67f32bb, 0x12df,
    // 0.1573, -0.1035, 0.014404, 0.05804, 0.25, -0.4414, -0.01761, 0.0, 0.2039, -0.1857, -0.11304, 0.06665, 0.2235, -0.3906, -0.03067, 0.0
    0xaea03109, 0x2b6e2360, 0xb7103400, 0xa482, 0xb1f13286, 0x2c44af3c, 0xb6403327, 0xa7da,
    // -0.0619, 0.07526, 0.06555, 0.2727, -0.277, -0.2341, 0.2012, 0.0, -0.01636, 0.07745, 0.1142, 0.408, -0.2559, -0.1818, 0.2693, 0.0
    0x2cd1abec, 0x345d2c32, 0xb37eb46f, 0x3270, 0x2cf5a430, 0x36872f4f, 0xb1d1b418, 0x344f,
    // -0.0471, 0.0638, 0.01935, 0.3455, -0.2212, -0.1112, 0.2275, 0.0, -0.05188, 0.05524, 0.1017, 0.3752, -0.2097, -0.12427, 0.2117, 0.0
    0x2c15aa07, 0x358724f4, 0xaf1eb314, 0x3348, 0x2b12aaa4, 0x36012e82, 0xaff4b2b6, 0x32c6,
    // 0.1113, -0.136, -0.975, -0.0421, 0.09283, 0.04022, 0.09894, 0.0, 0.0871, -0.0961, -0.9404, 0.0006294, 0.1425, 0.01729, 0.1576, 0.0
    0xb05a2f20, 0xa964bbcd, 0x29262df1, 0x2e55, 0xae272d93, 0x1128bb86, 0x246d308f, 0x310b,
    // 0.04276, -0.1055, -0.8906, -0.04526, 0.10974, 0.02647, 0.12415, 0.0, 0.08575, -0.04892, -0.9355, -0.04623, 0.06323, 0.00614, 0.104, 0.0
    0xaec12979, 0xa9cbbb20, 0x26c72f06, 0x2ff2, 0xaa432d7d, 0xa9ebbb7c, 0x1e4a2c0c, 0x2ea8,
    // -0.0985, 0.0938, -0.703, 0.04486, -0.003523, 0.003881, 0.006786, 0.0, -0.06116, 0.1256, -0.621, -0.02522, 0.001027, -0.09174, 0.01426, 0.0
    0x2e01ae4e, 0x29beb9a0, 0x1bf39b37, 0x1ef3, 0x3005abd4, 0xa675b8f8, 0xaddf1435, 0x234d,
    // -0.0679, 0.0863, -0.583, -0.005795, -0.02435, -0.02982, -0.01, 0.0, -0.10864, 0.1211, -0.5054, -0.04703, -0.08124, -0.07135, -0.01915, 0.0
    0x2d86ac58, 0x9defb8aa, 0xa7a2a63c, 0xa11f, 0x2fc0aef4, 0xaa05b80b, 0xac91ad33, 0xa4e7,
    // -0.05328, 0.1879, 0.2008, -0.1536, 0.1781, 0.05963, -0.01198, 0.0, -0.02835, 0.1383, 0.1893, -0.0883, 0.1169, 0.1588, 0.074, 0.0
    0x3203aad2, 0xb0ea326d, 0x2ba231b3, 0xa222, 0x306da742, 0xada7320f, 0x31152f7b, 0x2cbc,
    // -0.05716, 0.1792, 0.1713, 0.03102, 0.1434, -0.04385, 0.02657, 0.0, -0.1284, 0.1252, 0.1732, 0.09894, 0.04376, -0.04633, -0.0158, 0.0
    0x31bcab51, 0x27f1317b, 0xa99d3097, 0x26cd, 0x3002b01c, 0x2e55318b, 0xa9ee299a, 0xa40b,
    // 0.0941, -0.2615, 0.7036, 0.2039, 0.05508, 0.0735, -0.2058, 0.0, 0.0708, -0.12354, 0.7837, 0.05676, 0.04242, -0.001545, -0.03903, 0.0
    0xb42f2e06, 0x328639a1, 0x2cb42b0d, 0xb296, 0xafe82c88, 0x2b443a45, 0x9654296e, 0xa8ff,
    // 0.08124, -0.167, 0.6304, 0.1023, -0.05746, 0.13, -0.0678, 0.0, 0.1439, -0.0447, 0.7764, 0.04535, -0.1359, 0.00422, -0.10736, 0.0
    0xb1582d33, 0x2e8c390b, 0x3029ab5b, 0xac57, 0xa9b9309b, 0x29ce3a36, 0x1c52b059, 0xaedf,
    // 0.0918, 0.1868, 0.001615, 0.1871, -0.013466, 0.1582, -0.2484, 0.0, -0.001718, 0.1759, 0.0751, 0.01727, 0.1119, -0.0583, -0.1553, 0.0
    0x31fa2de0, 0x31fd169d, 0x3110a2e5, 0xb3f3, 0x31a19709, 0x246c2cce, 0xab762f29, 0xb0f8,
    // -0.01927, 0.07007, -0.0468, 0.0912, -0.07135, 0.1425, -0.1917, 0.0, -0.0573, 0.10443, 0.02748, -0.07916, 0.2573, -0.1, -0.0709, 0.0
    0x2c7ca4ef, 0x2dd6a9fe, 0x308fac91, 0xb222, 0x2eafab56, 0xad112709, 0xae66341e, 0xac8a,
    // -0.2751, -0.1782, 0.1294, -0.0354, -0.004215, -0.07336, -0.01817, 0.0, -0.182, 0.0646, 0.04977, -0.071, 0.05963, -0.03424, 0.02477, 0.0
    0xb1b4b467, 0xa8883024, 0xacb29c51, 0xa4a7, 0x2c22b1d3, 0xac8b2a5f, 0xa8622ba2, 0x2657,
    // -0.04575, 0.11566, 0.1919, 0.02405, 0.0805, -0.03268, -0.0799, 0.0, -0.02733, 0.3804, 0.04996, 0.0758, 0.2349, -0.07654, -0.01297, 0.0
    0x2f67a9db, 0x26283224, 0xa82f2d27, 0xad1d, 0x3616a6ff, 0x2cda2a65, 0xace63384, 0xa2a4,
    // 0.1005, -0.2306, -0.5947, 0.07086, -0.01947, 0.06714, -0.01502, 0.0, 0.10944, -0.1173, -0.4905, 0.1664, -0.1714, 0.11884, -0.1512, 0.0
    0xb3612e6f, 0x2c89b8c2, 0x2c4ca4fc, 0xa3b1, 0xaf822f01, 0x3153b7d9, 0x2f9bb17c, 0xb0d7,
    // 0.0648, -0.0655, -0.5664, 0.001044, -0.1372, -0.02332, 0.05453, 0.0, 0.1632, 0.06052, -0.5386, 0.02365, -0.1345, -0.11456, -0.01935, 0.0
    0xac312c26, 0x1447b888, 0xa5f8b064, 0x2afb, 0x2bbf3139, 0x260eb84f, 0xaf55b04e, 0xa4f4,
};

struct ConstantBuffer
{
    OptimizedConstants          main;
    AutoExposureSPDConstants    spdAutoExposure;
    RcasConstants               rcas;
    Pass0Weights                pass0_weights;
};

typedef struct FfxFsr4UpscalerResourceDescriptions {
    FfxCreateResourceDescription recurrent;                 ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>recurrent</i></c> resource.
    FfxCreateResourceDescription history;                   ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>history</i></c> resource.
    FfxCreateResourceDescription historyReprojected;         ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>historyReprojected</i></c> resource.
    FfxCreateResourceDescription rcasIntermediary;         ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>rcasIntermediary</i></c> resource.
    FfxCreateResourceDescription autoExposure;            ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>autoExposure</i></c> resource.
    FfxCreateResourceDescription defaultExposure;            ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>defaultExposure</i></c> resource.
    FfxCreateResourceDescription spdAtomicCounter;         ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>spdAtomicCounter</i></c> resource.
    FfxCreateResourceDescription lumaMip5;                ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>lumaMip5</i></c> resource.
    FfxCreateResourceDescription scratchBuffer;            ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>scratchBuffer</i></c> resource.
    FfxCreateResourceDescription initializerBuffer;         ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>initializerBuffer</i></c> resource.
    FfxCreateResourceDescription initializerBufferUpload; ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>initializerBufferUpload</i></c> resource.
    FfxCreateResourceDescription debugInformation;         ///< The <c><i>FfxCreateResourceDescription</i></c> for allocating the <c><i>debugInformation</i></c> resource.

} FfxFsr4UpscalerResourceDescriptions;

struct InternalFsr4Context
{
    InternalContextHeader header;
    FfxInterface          backendInterface;
    ffxApiMessage         fpMessage;
    FfxUInt32             effectContextId;

    // fsr4 algorithm internal resources
    FfxConstantBuffer constantBuffers[FFX_FSR4UPSCALER_CONSTANTBUFFER_COUNT];

    // 2 arrays of resources, as e.g. FFX_FSR3UPSCALER_RESOURCE_IDENTIFIER_LOCK_STATUS will use different resources when bound as SRV vs when bound as UAV
    FfxResourceInternal srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_COUNT];
    FfxResourceInternal uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_COUNT];

    // shader selection parameters
    fsr4_shaders::Preset modelPreset;
    fsr4_shaders::MaxResolution maxResolution;
    uint32_t             createFlags;
    bool                 modelCreated = false;
    bool supportsWmma = false;
    bool autoExposure, lowResMv, depthInverted, enableSharpening, nonlinearColorspace, colorspaceSrgb, colorspacePq, motionVectorJitterCancellation, allowDebugVisualization;
    FfxApiDimensions2D maxRenderSize;
    FfxApiDimensions2D maxUpscaleSize;

    // fsr4 psos
    std::array<FfxPipelineState, 14> model_pso;
    std::array<FfxPipelineState, 13> padding_pso;
    FfxPipelineState                 rcas_pso;
    FfxPipelineState                 spd_auto_exposure_pso;
    FfxPipelineState                 debug_view_pso;

    // we don't want the full FfxPipelineState as the binding information data is huge
    typedef struct delayedDestructionPipelineData
    {
        FfxRootSignature    rootSignature;
        FfxCommandSignature cmdSignature;
        FfxPipeline         pipeline;
        FfxUInt64           targetFrameId;
    } delayedDestructionPipelineData;

    static const FfxUInt32                                            modelPipelineCount     = 30;
    static const FfxUInt32                                            delayDestructionFrames = 5;
    static const FfxUInt32                                            delayDestructionCount  = delayDestructionFrames * modelPipelineCount;
    std::array<delayedDestructionPipelineData, delayDestructionCount> delayDestructedPipelines;
    FfxUInt64                                                         delayDestructionFrameId  = 0;
    FfxUInt64                                                         delayDestructionStartIdx = 0;
    FfxUInt64                                                         delayDestructionEndIdx   = 0;

    // fsr4 cb
    ConstantBuffer cbufferData = {};
    int                    frameIdx = 0;
    float          previousJitter[2] = {0};

    FfxWatermark* watermark;
};

typedef enum FfxFsr4UpscalerPass
{
    FFX_FSR4_PRE_PASS,
    FFX_FSR4_MODEL_PASS,
    FFX_FSR4_POST_PASS = 13,
    FFX_FSR4_RCAS_PASS,
    FFX_FSR4_SPD_AUTOEXPOSURE_PASS,
    FFX_FSR4_DEBUG_VIEW_PASS,
    FFX_FSR4_PRE_PASS_PADDING,
    FFX_FSR4_POST_PASS_PADDING,

    FFX_FSR4UPSCALER_PASS_COUNT               ///< The number of passes performed by FSR4.
} FfxFsr4UpscalerPass;

// this is here because it makes it easier to manage preset permutations
static FfxErrorCode ffxGetFSR4ShaderBlob(FfxPass passId, uint32_t permutationOptions, FfxShaderBlob* outBlob)
{
    if (passId > FFX_FSR4_PRE_PASS && passId < FFX_FSR4_POST_PASS)
    {
        *outBlob = fsr4_shaders::GetModelShaderBlob(passId, permutationOptions);
        return FFX_OK;
    }
    else if (passId >= FFX_FSR4_PRE_PASS_PADDING)
    {
        *outBlob = fsr4_shaders::GetPaddingResetBlob(passId - FFX_FSR4_PRE_PASS_PADDING, permutationOptions);
        return FFX_OK;
    }
    else
    {
        switch (passId)
        {
        case FFX_FSR4_PRE_PASS:
            *outBlob = fsr4_shaders::GetPreShaderBlob(permutationOptions);
            return FFX_OK;
        case FFX_FSR4_POST_PASS:
            *outBlob = fsr4_shaders::GetPostShaderBlob(permutationOptions);
            return FFX_OK;
        case FFX_FSR4_RCAS_PASS:
            *outBlob = fsr4_shaders::GetRcasBlob(permutationOptions);
            return FFX_OK;
        case FFX_FSR4_SPD_AUTOEXPOSURE_PASS:
            *outBlob = fsr4_shaders::GetSPDAutoExposureBlob();
            return FFX_OK;
        case FFX_FSR4_DEBUG_VIEW_PASS:
            *outBlob = fsr4_shaders::GetDebugViewBlob(permutationOptions);
            return FFX_OK;
        default:
            return FFX_ERROR_BACKEND_API_ERROR;
        }
    }
}

static ffxReturnCode_t patchResourceBindings(FfxPipelineState* inoutPipeline)
{
    for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvTextureCount; ++srvIndex)
    {
        int32_t mapIndex = 0;
        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
        {
            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvTextureBindings[srvIndex].name))
                break;
        }
        if (mapIndex == _countof(srvTextureBindingTable))
            return FFX_API_RETURN_ERROR_PARAMETER;

        inoutPipeline->srvTextureBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
    }

    for (uint32_t srvIndex = 0; srvIndex < inoutPipeline->srvBufferCount; ++srvIndex)
    {
        int32_t mapIndex = 0;
        for (mapIndex = 0; mapIndex < _countof(srvTextureBindingTable); ++mapIndex)
        {
            if (0 == wcscmp(srvTextureBindingTable[mapIndex].name, inoutPipeline->srvBufferBindings[srvIndex].name))
                break;
        }
        if (mapIndex == _countof(srvTextureBindingTable))
            return FFX_API_RETURN_ERROR_PARAMETER;

        inoutPipeline->srvBufferBindings[srvIndex].resourceIdentifier = srvTextureBindingTable[mapIndex].index;
    }

    for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavTextureCount; ++uavIndex)
    {
        int32_t mapIndex = 0;
        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
        {
            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavTextureBindings[uavIndex].name))
                break;
        }
        if (mapIndex == _countof(uavTextureBindingTable))
            return FFX_API_RETURN_ERROR_PARAMETER;

        inoutPipeline->uavTextureBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
    }

    for (uint32_t uavIndex = 0; uavIndex < inoutPipeline->uavBufferCount; ++uavIndex)
    {
        int32_t mapIndex = 0;
        for (mapIndex = 0; mapIndex < _countof(uavTextureBindingTable); ++mapIndex)
        {
            if (0 == wcscmp(uavTextureBindingTable[mapIndex].name, inoutPipeline->uavBufferBindings[uavIndex].name))
                break;
        }
        if (mapIndex == _countof(uavTextureBindingTable))
            return FFX_API_RETURN_ERROR_PARAMETER;

        inoutPipeline->uavBufferBindings[uavIndex].resourceIdentifier = uavTextureBindingTable[mapIndex].index;
    }

    for (uint32_t cbIndex = 0; cbIndex < inoutPipeline->constCount; ++cbIndex)
    {
        int32_t mapIndex = 0;
        for (mapIndex = 0; mapIndex < _countof(constantBufferBindingTable); ++mapIndex)
        {
            if (0 == wcscmp(constantBufferBindingTable[mapIndex].name, inoutPipeline->constantBufferBindings[cbIndex].name))
                break;
        }
        if (mapIndex == _countof(constantBufferBindingTable))
            return FFX_API_RETURN_ERROR_PARAMETER;

        inoutPipeline->constantBufferBindings[cbIndex].resourceIdentifier = constantBufferBindingTable[mapIndex].index;
    }

    return FFX_API_RETURN_OK;
}

static void PushDelayedPipelineDestruction(InternalFsr4Context* internal_context, FfxPipelineState* pPipelinestate)
{
    InternalFsr4Context::delayedDestructionPipelineData data;
    data.cmdSignature  = pPipelinestate->cmdSignature;
    data.pipeline      = pPipelinestate->pipeline;
    data.rootSignature = pPipelinestate->rootSignature;

    // don't push empty pipelines, this further reduces risk of the ringbuffer overflowing
    if ((data.cmdSignature != nullptr) || (data.pipeline != nullptr) || (data.rootSignature != nullptr))
    {
        // increase ringbuffer end index, wrap around at count
        FfxUInt64 nextIdx = internal_context->delayDestructionEndIdx;
        if (++internal_context->delayDestructionEndIdx == internal_context->delayDestructionCount)
            internal_context->delayDestructionEndIdx = 0;

        // assure we're not overfilling the ringbuffer
        FFX_ASSERT(internal_context->delayDestructionEndIdx != internal_context->delayDestructionStartIdx);

        data.targetFrameId = internal_context->delayDestructionFrameId + InternalFsr4Context::delayDestructionFrames;
        internal_context->delayDestructedPipelines[nextIdx] = data;
    }
}

static void CheckDelayedPipelineDestruction(InternalFsr4Context* internal_context, bool force = false)
{
    // early out if the ringbuffer is completely empty
    if (internal_context->delayDestructionEndIdx == internal_context->delayDestructionStartIdx)
        return;

    // it's ok to only increase the frameId if pipelines are waiting for destruction
    internal_context->delayDestructionFrameId = internal_context->delayDestructionFrameId + (force ? InternalFsr4Context::delayDestructionFrames : 1);

    while ((internal_context->delayDestructedPipelines[internal_context->delayDestructionStartIdx].targetFrameId < internal_context->delayDestructionFrameId) &&
           (internal_context->delayDestructionStartIdx != internal_context->delayDestructionEndIdx))
    {
        auto             data = internal_context->delayDestructedPipelines[internal_context->delayDestructionStartIdx];
        FfxPipelineState pipeline;
        pipeline.cmdSignature  = data.cmdSignature;
        pipeline.pipeline      = data.pipeline;
        pipeline.rootSignature = data.rootSignature;

        ffxSafeReleasePipeline(&internal_context->backendInterface, &pipeline, internal_context->effectContextId);

        internal_context->delayDestructedPipelines[internal_context->delayDestructionStartIdx] = {};

        // increase start index, don't forget to warp!
        if (++internal_context->delayDestructionStartIdx == internal_context->delayDestructionCount)
            internal_context->delayDestructionStartIdx = 0;
    }
}

static void DestroyPipelines(InternalFsr4Context* internal_context)
{
    for (int i = 0; i < internal_context->model_pso.size(); i++)
    {
        PushDelayedPipelineDestruction(internal_context, &internal_context->model_pso[i]);
    }

    for (int i = 0; i < internal_context->padding_pso.size(); i++)
    {
        PushDelayedPipelineDestruction(internal_context, &internal_context->padding_pso[i]);
    }

    PushDelayedPipelineDestruction(internal_context, &internal_context->rcas_pso);
    PushDelayedPipelineDestruction(internal_context, &internal_context->spd_auto_exposure_pso);
    PushDelayedPipelineDestruction(internal_context, &internal_context->debug_view_pso);
}


static ffxReturnCode_t CreateModel(InternalFsr4Context* internal_context, fsr4_shaders::Preset modelPreset)
{
    DestroyPipelines(internal_context);

    // upload initializer data
    {
        void* initializerData;
        size_t initializerSize;
        fsr4_shaders::GetInitializer(modelPreset, internal_context->supportsWmma, initializerData, initializerSize);
        void* initDataMapped;
        TRY2(internal_context->backendInterface.fpMapResource(&internal_context->backendInterface, internal_context->srvResources[FFX_MLSR_BIND_SRV_INITIALIZER_STAGING_BUFFER], &initDataMapped));

        memcpy(initDataMapped, initializerData, initializerSize);

        TRY2(internal_context->backendInterface.fpUnmapResource(&internal_context->backendInterface, internal_context->srvResources[FFX_MLSR_BIND_SRV_INITIALIZER_STAGING_BUFFER]));

        // copy the data from the staging buffer to the gpu
        FfxGpuJobDescription copyJob  = { FFX_GPU_JOB_COPY, L"Resource Initialization Copy" };
        copyJob.copyJobDescriptor.src = internal_context->srvResources[FFX_MLSR_BIND_SRV_INITIALIZER_STAGING_BUFFER];
        copyJob.copyJobDescriptor.dst = internal_context->srvResources[FFX_MLSR_BIND_SRV_INITIALIZER_BUFFER];
        copyJob.copyJobDescriptor.srcOffset = 0;
        copyJob.copyJobDescriptor.dstOffset = 0;
        copyJob.copyJobDescriptor.size      = static_cast<uint32_t>(initializerSize);

        internal_context->backendInterface.fpScheduleGpuJob(&internal_context->backendInterface, &copyJob);
    }

    // clear scratch buffer
    {
        // FfxGpuJobDescription clearJob = {FFX_GPU_JOB_CLEAR, L"Scratch Buffer Clear"};
        // clearJob.color                = {0, 0, 0, 0};
        // clearJob.target               = internal_context->srvResources[FFX_MLSR_BIND_SRV_SCRATCH_BUFFER];
        // internal_context->backendInterface.fpScheduleGpuJob(&internal_context->backendInterface, &clearJob);
    }

    FfxPipelineDescription pipelineDescription = {};
    pipelineDescription.contextFlags           = 0;
    pipelineDescription.stage                  = FFX_BIND_COMPUTE_SHADER_STAGE;

    // Samplers
    pipelineDescription.samplerCount      = 1;
    FfxSamplerDescription samplerDescs[1] = {
        {FFX_FILTER_TYPE_MINMAGMIP_LINEAR, FFX_ADDRESS_MODE_CLAMP, FFX_ADDRESS_MODE_CLAMP, FFX_ADDRESS_MODE_CLAMP, FFX_BIND_COMPUTE_SHADER_STAGE}};
    pipelineDescription.samplers = samplerDescs;

    // Root constants
    pipelineDescription.rootConstantBufferCount     = 1;
    FfxRootConstantDescription rootConstantDescs[1] = {{sizeof(ConstantBuffer) / sizeof(uint32_t), FFX_BIND_COMPUTE_SHADER_STAGE},
                                                       };
    pipelineDescription.rootConstants               = rootConstantDescs;

    FSR4_ASSERT(1 << fsr4_shaders::qualityPresetBitShift > (uint32_t)modelPreset);

    uint32_t permutationKey = fsr4_shaders::PermutationOptionsToKey(modelPreset,
        internal_context->maxResolution,
        internal_context->supportsWmma,
        internal_context->depthInverted,
        internal_context->lowResMv,
        internal_context->autoExposure,
        internal_context->motionVectorJitterCancellation,
        internal_context->nonlinearColorspace,
        internal_context->colorspaceSrgb,
        internal_context->colorspacePq,
        internal_context->allowDebugVisualization
    );

    FfxShaderBlob shaderBlob     = {};
    // pre and post passes
    ffxGetFSR4ShaderBlob(FFX_FSR4_PRE_PASS, permutationKey, &shaderBlob);
    wcscpy_s(pipelineDescription.name, L"FFX_FSR4_PRE_PASS");
    TRY2(internal_context->backendInterface.fpCreatePipeline(&internal_context->backendInterface,
                                                                     &shaderBlob,
                                                                     &pipelineDescription,
                                                                     internal_context->effectContextId,
                                                                     &internal_context->model_pso[0]));

    ffxGetFSR4ShaderBlob(FFX_FSR4_POST_PASS, permutationKey, &shaderBlob);
    wcscpy_s(pipelineDescription.name, L"FFX_FSR4_POST_PASS");
    TRY2(internal_context->backendInterface.fpCreatePipeline(&internal_context->backendInterface,
                                                                     &shaderBlob,
                                                                     &pipelineDescription,
                                                                     internal_context->effectContextId,
                                                                     &internal_context->model_pso[13]));
                                                                     
    // create model PSOs
    for (uint32_t passIndex = 1; passIndex < 13; ++passIndex)
    {
        std::format_to_n(&pipelineDescription.name[0], 64, L"FFX_FSR4_MODEL_PASS_{}\0"sv, passIndex);
        ffxGetFSR4ShaderBlob(passIndex, permutationKey, &shaderBlob);
        TRY2(internal_context->backendInterface.fpCreatePipeline(
            &internal_context->backendInterface,
            &shaderBlob,
            &pipelineDescription,
            internal_context->effectContextId,
            &internal_context->model_pso[passIndex]));

        TRY(patchResourceBindings(&internal_context->model_pso[passIndex]));
    }

    // create padding PSOs
    if (internal_context->supportsWmma)
    {
        for (uint32_t passIndex = 0; passIndex < 13; ++passIndex)
        {
            std::format_to_n(&pipelineDescription.name[0], 64, L"FFX_FSR4_MODEL_PASS_{}_POST\0"sv, passIndex);
            ffxGetFSR4ShaderBlob(FFX_FSR4_PRE_PASS_PADDING + passIndex, permutationKey, &shaderBlob);
            TRY2(internal_context->backendInterface.fpCreatePipeline(
                &internal_context->backendInterface,
                &shaderBlob,
                &pipelineDescription,
                internal_context->effectContextId,
                &internal_context->padding_pso[passIndex]));

            TRY(patchResourceBindings(&internal_context->padding_pso[passIndex]));
        }
    }

    // auto exposure
    ffxGetFSR4ShaderBlob(FFX_FSR4_SPD_AUTOEXPOSURE_PASS, 0, &shaderBlob);
    wcscpy_s(pipelineDescription.name, L"FFX_FSR4_SPD_AUTOEXPOSURE_PASS");
    TRY2(internal_context->backendInterface.fpCreatePipeline(&internal_context->backendInterface,
                                                             &shaderBlob,
                                                             &pipelineDescription,
                                                             internal_context->effectContextId,
                                                             &internal_context->spd_auto_exposure_pso));

    //rcas
    ffxGetFSR4ShaderBlob(FFX_FSR4_RCAS_PASS, permutationKey, &shaderBlob);
    wcscpy_s(pipelineDescription.name, L"FFX_FSR4_RCAS_PASS");
    TRY2(internal_context->backendInterface.fpCreatePipeline(&internal_context->backendInterface,
                                                                     &shaderBlob,
                                                                     &pipelineDescription,
                                                                     internal_context->effectContextId,
                                                                     &internal_context->rcas_pso));

    //debug view
    ffxGetFSR4ShaderBlob(FFX_FSR4_DEBUG_VIEW_PASS, permutationKey, &shaderBlob);
    wcscpy_s(pipelineDescription.name, L"FFX_FSR4_DEBUG_VIEW_PASS");
    TRY2(internal_context->backendInterface.fpCreatePipeline(&internal_context->backendInterface,
                                                                     &shaderBlob,
                                                                     &pipelineDescription,
                                                                     internal_context->effectContextId,
                                                                     &internal_context->debug_view_pso));

    TRY(patchResourceBindings(&internal_context->model_pso[0]));
    TRY(patchResourceBindings(&internal_context->model_pso[13]));
    TRY(patchResourceBindings(&internal_context->rcas_pso));
    TRY(patchResourceBindings(&internal_context->spd_auto_exposure_pso));
    TRY(patchResourceBindings(&internal_context->debug_view_pso));

    switch (modelPreset)
    {
    case fsr4_shaders::Preset::NativeAA:
        memcpy_s(&internal_context->cbufferData.pass0_weights, sizeof(internal_context->cbufferData.pass0_weights), weights_native, sizeof(weights_native));
        break;
    case fsr4_shaders::Preset::Quality:
        memcpy_s(&internal_context->cbufferData.pass0_weights, sizeof(internal_context->cbufferData.pass0_weights), weights_quality, sizeof(weights_quality));
        break;
    case fsr4_shaders::Preset::Balanced:
        memcpy_s(&internal_context->cbufferData.pass0_weights, sizeof(internal_context->cbufferData.pass0_weights), weights_balanced, sizeof(weights_balanced));
        break;
    case fsr4_shaders::Preset::Performance:
        memcpy_s(&internal_context->cbufferData.pass0_weights, sizeof(internal_context->cbufferData.pass0_weights), weights_performance, sizeof(weights_performance));
        break;
    case fsr4_shaders::Preset::DRS:
        memcpy_s(&internal_context->cbufferData.pass0_weights, sizeof(internal_context->cbufferData.pass0_weights), weights_drs, sizeof(weights_drs));
        break;
    case fsr4_shaders::Preset::UltraPerformance:
        memcpy_s(&internal_context->cbufferData.pass0_weights, sizeof(internal_context->cbufferData.pass0_weights), weights_ultraperf, sizeof(weights_ultraperf));
        break;
    }
    return FFX_API_RETURN_OK;
}

static void getResourceDescriptions(const FfxApiDimensions2D* maxRenderSize, const FfxApiDimensions2D* maxUpscaleSize, FfxFsr4UpscalerResourceDescriptions* resourceDescriptions)
{
    resourceDescriptions->recurrent = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_TEXTURE2D, FFX_API_SURFACE_FORMAT_R8G8B8A8_UNORM, maxUpscaleSize->width, maxUpscaleSize->height, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, (FFX_API_RESOURCE_USAGE_RENDERTARGET | FFX_API_RESOURCE_USAGE_UAV) },
        FFX_API_RESOURCE_STATE_UNORDERED_ACCESS,
        L"FSR4UPSCALER_Recurrent",
        FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RECURRENT,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };
    resourceDescriptions->history = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_TEXTURE2D, FFX_API_SURFACE_FORMAT_R16G16B16A16_FLOAT, maxUpscaleSize->width, maxUpscaleSize->height, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, (FFX_API_RESOURCE_USAGE_RENDERTARGET | FFX_API_RESOURCE_USAGE_UAV) },
        FFX_API_RESOURCE_STATE_UNORDERED_ACCESS,
        L"FSR4UPSCALER_History",
        FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_HISTORY,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };
    resourceDescriptions->historyReprojected = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_TEXTURE2D, FFX_API_SURFACE_FORMAT_R16G16B16A16_FLOAT, maxUpscaleSize->width, maxUpscaleSize->height, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, (FFX_API_RESOURCE_USAGE_RENDERTARGET | FFX_API_RESOURCE_USAGE_UAV) },
        FFX_API_RESOURCE_STATE_UNORDERED_ACCESS,
        L"FSR4UPSCALER_HistoryReprojected",
        FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_HISTORY_REPROJECTED,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };
    resourceDescriptions->rcasIntermediary = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_TEXTURE2D, FFX_API_SURFACE_FORMAT_R16G16B16A16_FLOAT, maxUpscaleSize->width, maxUpscaleSize->height, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, (FFX_API_RESOURCE_USAGE_RENDERTARGET | FFX_API_RESOURCE_USAGE_UAV) },
        FFX_API_RESOURCE_STATE_UNORDERED_ACCESS,
        L"FSR4UPSCALER_RcasIntermediary",
        FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RCAS_TEMP,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };
    resourceDescriptions->autoExposure = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_TEXTURE2D, FFX_API_SURFACE_FORMAT_R32_FLOAT, 2, 1, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, (FFX_API_RESOURCE_USAGE_RENDERTARGET | FFX_API_RESOURCE_USAGE_UAV) },
        FFX_API_RESOURCE_STATE_UNORDERED_ACCESS,
        L"FSR4UPSCALER_AutoExposure",
        FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_AUTO_EXPOSURE,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };

    float defaultExposure[] = { 1.0f, 1.0f };
    resourceDescriptions->defaultExposure = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_TEXTURE2D, FFX_API_SURFACE_FORMAT_R32G32_FLOAT, 1, 1, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, FFX_API_RESOURCE_USAGE_READ_ONLY },
        FFX_API_RESOURCE_STATE_COMPUTE_READ,
        L"FSR3UPSCALER_DefaultExposure",
        FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_EXPOSURE,
        FfxResourceInitData::FfxResourceInitBuffer(sizeof(defaultExposure), defaultExposure)
    };

    resourceDescriptions->spdAtomicCounter = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_TEXTURE2D, FFX_API_SURFACE_FORMAT_R32_UINT, 1, 1, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, (FFX_API_RESOURCE_USAGE_UAV) },
        FFX_API_RESOURCE_STATE_UNORDERED_ACCESS,
        L"FSR4UPSCALER_SpdAtomicCounter",
        FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT,
        FfxResourceInitData::FfxResourceInitValue(sizeof(uint32_t), 0)
    };
    resourceDescriptions->lumaMip5 = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_TEXTURE2D, FFX_API_SURFACE_FORMAT_R32_FLOAT, RoundUpDiv(maxRenderSize->width, 16ui32), RoundUpDiv(maxRenderSize->height, 16ui32), 1, 1, FFX_API_RESOURCE_FLAGS_NONE, (FFX_API_RESOURCE_USAGE_RENDERTARGET | FFX_API_RESOURCE_USAGE_UAV) },
        FFX_API_RESOURCE_STATE_UNORDERED_ACCESS,
        L"FSR4UPSCALER_Luma_Mip_5",
        FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_SPD_MIP5,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };
    fsr4_shaders::MaxResolution maxResolution = fsr4_shaders::MaxResolution::Res_1920_1080;
    if (maxUpscaleSize->width > 1920 || maxUpscaleSize->height > 1080)
        maxResolution = fsr4_shaders::MaxResolution::Res_3840_2160;
    if (maxUpscaleSize->width > 3840 || maxUpscaleSize->height > 2160)
        maxResolution = fsr4_shaders::MaxResolution::Res_7680_4320;
    resourceDescriptions->scratchBuffer = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_BUFFER, FFX_API_SURFACE_FORMAT_R32_TYPELESS, static_cast<uint32_t> (fsr4_shaders::GetScratchSize(maxResolution)), 0, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, FFX_API_RESOURCE_USAGE_UAV },
        FFX_API_RESOURCE_STATE_UNORDERED_ACCESS,
        L"FSR4UPSCALER_ScratchBuffer",
        FFX_MLSR_BIND_SRV_SCRATCH_BUFFER,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };

    // Initializer Buffer
    resourceDescriptions->initializerBuffer = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_BUFFER, FFX_API_SURFACE_FORMAT_R32_TYPELESS, static_cast<uint32_t> (fsr4_shaders::GetInitializerSize()), 0, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, FFX_API_RESOURCE_USAGE_READ_ONLY },
        FFX_API_RESOURCE_STATE_COMPUTE_READ,
        L"FSR4UPSCALER_InitializerBuffer",
        FFX_MLSR_BIND_SRV_INITIALIZER_BUFFER,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };

    // Initializer Buffer Upload
    resourceDescriptions->initializerBufferUpload = {
        FFX_HEAP_TYPE_UPLOAD,
        { FFX_API_RESOURCE_TYPE_BUFFER, FFX_API_SURFACE_FORMAT_R32_TYPELESS, static_cast<uint32_t> (fsr4_shaders::GetInitializerSize()), 0, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, FFX_API_RESOURCE_USAGE_READ_ONLY },
        FFX_API_RESOURCE_STATE_COMPUTE_READ,
        L"FSR4UPSCALER_InitializerBuffer_Upload",
        FFX_MLSR_BIND_SRV_INITIALIZER_STAGING_BUFFER,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };

    // Debug Information
    resourceDescriptions->debugInformation = {
        FFX_HEAP_TYPE_DEFAULT,
        { FFX_API_RESOURCE_TYPE_TEXTURE2D, FFX_API_SURFACE_FORMAT_R16_UNORM, maxUpscaleSize->width, maxUpscaleSize->height, 1, 1, FFX_API_RESOURCE_FLAGS_NONE, (FFX_API_RESOURCE_USAGE_RENDERTARGET | FFX_API_RESOURCE_USAGE_UAV) },
        FFX_API_RESOURCE_STATE_UNORDERED_ACCESS,
        L"FSR4UPSCALER_DebugInformation",
        FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_DEBUG_INFORMATION,
        { FFX_RESOURCE_INIT_DATA_TYPE_UNINITIALIZED }
    };
}

ffxReturnCode_t ffxProvider_FSR4::CreateContext(ffxContext* context, ffxCreateContextDescHeader* header, Allocator& alloc) const
{
    VERIFY(context, FFX_API_RETURN_ERROR_PARAMETER);
    VERIFY(header, FFX_API_RETURN_ERROR_PARAMETER);

    if (auto desc = ffx::DynamicCast<ffxCreateContextDescUpscale>(header))
    {
        // check resolution support first, avoid allocation if we need to error out early.
        fsr4_shaders::MaxResolution maxResolution = fsr4_shaders::MaxResolution::Res_1920_1080;
        if (desc->maxUpscaleSize.width > 1920 || desc->maxUpscaleSize.height > 1080)
            maxResolution = fsr4_shaders::MaxResolution::Res_3840_2160;
        if (desc->maxUpscaleSize.width > 3840 || desc->maxUpscaleSize.height > 2160)
            maxResolution = fsr4_shaders::MaxResolution::Res_7680_4320;
        if (desc->maxUpscaleSize.width > 7680 || desc->maxUpscaleSize.height > 4320)
            return FFX_API_RETURN_ERROR;

        InternalFsr4Context* internal_context = alloc.construct<InternalFsr4Context>();
        VERIFY(internal_context, FFX_API_RETURN_ERROR_MEMORY);
        internal_context->header.provider = this;

        internal_context->maxResolution = maxResolution;

        TRY(MustCreateBackend(header, &internal_context->backendInterface, 1, alloc));
        internal_context->supportsWmma = EnableAMDExtensions(GetDevice(header));
#if FSR4_ENABLE_DOT4
        internal_context->supportsWmma &= std::getenv("MLSR-WMMA") != nullptr;
#endif

        // Create the context.
        FfxEffectBindlessConfig fsr4BindlessConfig = {0, 0, 0, 1 };
        TRY2(internal_context->backendInterface.fpCreateBackendContext(&internal_context->backendInterface, FFX_EFFECT_SHAREDRESOURCES, &fsr4BindlessConfig, &internal_context->effectContextId));

        // Create FSR4 context
        internal_context->modelPreset = fsr4_shaders::Preset::NativeAA;
        internal_context->maxRenderSize = {desc->maxRenderSize.width, desc->maxRenderSize.height};
        internal_context->maxUpscaleSize = {AlignUp(desc->maxUpscaleSize.width, 8u), AlignUp(desc->maxUpscaleSize.height, 8u)};
        float scalingRatio = static_cast<float>(desc->maxUpscaleSize.width) / static_cast<float>(desc->maxRenderSize.width);
        if (scalingRatio >= 1.49f) internal_context->modelPreset = fsr4_shaders::Preset::Quality;
        if (scalingRatio >= 1.69f) internal_context->modelPreset = fsr4_shaders::Preset::Balanced;
        if (scalingRatio >= 1.99f) internal_context->modelPreset = fsr4_shaders::Preset::Performance;
        if (scalingRatio >= 2.99f) internal_context->modelPreset = fsr4_shaders::Preset::UltraPerformance;

        // FfxFsrUpscaleInitializationFlagBits
        const bool bHDR = (desc->flags & FFX_UPSCALE_ENABLE_HIGH_DYNAMIC_RANGE) == FFX_UPSCALE_ENABLE_HIGH_DYNAMIC_RANGE;
        const bool bHighResMV = (desc->flags & FFX_UPSCALE_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS) == FFX_UPSCALE_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS;
        const bool bMVJitterCancellation = (desc->flags & FFX_UPSCALE_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION) == FFX_UPSCALE_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION;
        const bool bDepthInverted = (desc->flags & FFX_UPSCALE_ENABLE_DEPTH_INVERTED) == FFX_UPSCALE_ENABLE_DEPTH_INVERTED;
        const bool bDepthInfinite = (desc->flags & FFX_UPSCALE_ENABLE_DEPTH_INFINITE) == FFX_UPSCALE_ENABLE_DEPTH_INFINITE;
        const bool bAutoExposure  = (desc->flags & FFX_UPSCALE_ENABLE_AUTO_EXPOSURE) == FFX_UPSCALE_ENABLE_AUTO_EXPOSURE;
        const bool bDynamicRes = (desc->flags & FFX_UPSCALE_ENABLE_DYNAMIC_RESOLUTION) == FFX_UPSCALE_ENABLE_DYNAMIC_RESOLUTION;
        const bool bDebugCheck = (desc->flags & FFX_UPSCALE_ENABLE_DEBUG_CHECKING) == FFX_UPSCALE_ENABLE_DEBUG_CHECKING;
        const bool bNonlinearColorspace = (desc->flags & FFX_UPSCALE_ENABLE_NON_LINEAR_COLORSPACE) == FFX_UPSCALE_ENABLE_NON_LINEAR_COLORSPACE;
        const bool bAllowDebugVisualization = (desc->flags & FFX_UPSCALE_ENABLE_DEBUG_VISUALIZATION) == FFX_UPSCALE_ENABLE_DEBUG_VISUALIZATION;

        if (bDynamicRes)
            internal_context->modelPreset = fsr4_shaders::Preset::DRS;

        internal_context->createFlags = desc->flags;
        internal_context->autoExposure = bAutoExposure;
        internal_context->lowResMv = !bHighResMV;
        internal_context->depthInverted = bDepthInverted;
        internal_context->nonlinearColorspace = bNonlinearColorspace;

        // on context create, default the colorspace flags to false
        internal_context->colorspaceSrgb = false;
        internal_context->colorspacePq = false;
        internal_context->motionVectorJitterCancellation = bMVJitterCancellation;
        internal_context->allowDebugVisualization = bAllowDebugVisualization;

        size_t envVarExists = 0;
        getenv_s(&envVarExists, nullptr, 0, "MLSR-WATERMARK");
        if (envVarExists)
        {
            internal_context->watermark = alloc.construct<FfxWatermark>(&internal_context->backendInterface, internal_context->effectContextId);
        }

        FfxFsr4UpscalerResourceDescriptions fsr4UpscalerResourceDescs = {};
        getResourceDescriptions(&internal_context->maxRenderSize, &internal_context->maxUpscaleSize, &fsr4UpscalerResourceDescs);

        const FfxCreateResourceDescription* resources[] = {
            &fsr4UpscalerResourceDescs.recurrent,
            &fsr4UpscalerResourceDescs.history,
            &fsr4UpscalerResourceDescs.historyReprojected,
            &fsr4UpscalerResourceDescs.rcasIntermediary,
            &fsr4UpscalerResourceDescs.autoExposure,
            &fsr4UpscalerResourceDescs.defaultExposure,
            &fsr4UpscalerResourceDescs.spdAtomicCounter,
            &fsr4UpscalerResourceDescs.lumaMip5,
            &fsr4UpscalerResourceDescs.scratchBuffer,
            &fsr4UpscalerResourceDescs.initializerBuffer,
            &fsr4UpscalerResourceDescs.initializerBufferUpload,
            &fsr4UpscalerResourceDescs.debugInformation
        };

        // clear the SRV resources to NULL.
        memset(internal_context->srvResources, 0, sizeof(internal_context->srvResources));

        const size_t resourceCount = sizeof(resources) / sizeof(resources[0]);
        for (size_t i = 0; i < resourceCount; ++i)
        {
            const FfxCreateResourceDescription* createResourceDescription = resources[i];
            if (!internal_context->allowDebugVisualization && createResourceDescription->id == FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_DEBUG_INFORMATION)
                continue;
            TRY2(internal_context->backendInterface.fpCreateResource(&internal_context->backendInterface,
                createResourceDescription,
                internal_context->effectContextId,
                &internal_context->srvResources[createResourceDescription->id]));
        }

        // copy resources to uavResrouces list
        memcpy(internal_context->uavResources, internal_context->srvResources, sizeof(internal_context->srvResources));

        *context = internal_context;
        return FFX_API_RETURN_OK;
    }
    else
    {
        return FFX_API_RETURN_ERROR_UNKNOWN_DESCTYPE;
    }
}

ffxReturnCode_t ffxProvider_FSR4::DestroyContext(ffxContext* context, Allocator& alloc) const
{
    VERIFY(context, FFX_API_RETURN_ERROR_PARAMETER);
    VERIFY(*context, FFX_API_RETURN_ERROR_PARAMETER);

    InternalFsr4Context* internal_context = reinterpret_cast<InternalFsr4Context*>(*context);

    DestroyPipelines(internal_context);

    CheckDelayedPipelineDestruction(internal_context, true);

    // Unregister external resources
    internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_COLOR] = {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_NULL};
    internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_DEPTH] = {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_NULL};
    internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS] = {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_NULL};
    internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_EXPOSURE] = {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_NULL};    
    internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RESULT_COLOR] = {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_NULL};

    internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_FINAL_OUTPUT] = {FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_NULL};

    // Release the copy resources for those that had init data
    ffxSafeReleaseCopyResource(&internal_context->backendInterface, internal_context->srvResources[FFX_MLSR_BIND_SRV_INITIALIZER_BUFFER],
                               internal_context->effectContextId);
    ffxSafeReleaseCopyResource(&internal_context->backendInterface, internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT],
                               internal_context->effectContextId);
    ffxSafeReleaseCopyResource(&internal_context->backendInterface, internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_EXPOSURE],
                               internal_context->effectContextId);

    // release internal resources
    for (int32_t currentResourceIndex = 0; currentResourceIndex < FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_COUNT; ++currentResourceIndex)
    {
        ffxSafeReleaseResource(&internal_context->backendInterface, internal_context->srvResources[currentResourceIndex], internal_context->effectContextId);
    }

    // Destroy FSR4 context
    internal_context->backendInterface.fpDestroyBackendContext(&internal_context->backendInterface, internal_context->effectContextId);

    alloc.dealloc(internal_context->backendInterface.scratchBuffer);
    alloc.dealloc(internal_context);
    *context = nullptr;

    return FFX_API_RETURN_OK;
}

ffxReturnCode_t ffxProvider_FSR4::Configure(ffxContext*, const ffxConfigureDescHeader*) const
{
    return FFX_API_RETURN_OK;
}

ffxReturnCode_t ffxProvider_FSR4::Query(ffxContext* context, ffxQueryDescHeader* header) const
{
    VERIFY(header, FFX_API_RETURN_ERROR_PARAMETER);

    switch (header->type)
    {
    case FFX_API_QUERY_DESC_TYPE_UPSCALE_GETJITTEROFFSET:
    {
        auto desc = reinterpret_cast<ffxQueryDescUpscaleGetJitterOffset*>(header);
        float jitterX, jitterY;
        TRY2(ffxFsr3UpscalerGetJitterOffset(&jitterX, &jitterY, desc->index, desc->phaseCount));
        if (desc->pOutX != nullptr)
        {
            *desc->pOutX = jitterX;
        }
        if (desc->pOutY != nullptr)
        {
            *desc->pOutY = jitterY;
        }
        break;
    }
    case FFX_API_QUERY_DESC_TYPE_UPSCALE_GETJITTERPHASECOUNT:
    {
        auto desc = reinterpret_cast<ffxQueryDescUpscaleGetJitterPhaseCount*>(header);
        const int32_t jitterPhaseCount = ffxFsr3UpscalerGetJitterPhaseCount(desc->renderWidth, desc->displayWidth);

        if (desc->pOutPhaseCount != nullptr)
        {
            *desc->pOutPhaseCount = jitterPhaseCount;
        }
        break;
    }
    case FFX_API_QUERY_DESC_TYPE_UPSCALE_GETRENDERRESOLUTIONFROMQUALITYMODE:
    {
        auto desc = reinterpret_cast<ffxQueryDescUpscaleGetRenderResolutionFromQualityMode*>(header);
        uint32_t renderWidth;
        uint32_t renderHeight;

        TRY2(ffxFsr3UpscalerGetRenderResolutionFromQualityMode(&renderWidth, &renderHeight, desc->displayWidth, desc->displayHeight, ConvertEnum<FfxApiUpscaleQualityMode>(desc->qualityMode)));
        if (desc->pOutRenderWidth != nullptr)
        {
            *desc->pOutRenderWidth = renderWidth;
        }
        if (desc->pOutRenderHeight != nullptr)
        {
            *desc->pOutRenderHeight = renderHeight;
        }
        break;
    }
    case FFX_API_QUERY_DESC_TYPE_UPSCALE_GETUPSCALERATIOFROMQUALITYMODE:
    {
        auto desc = reinterpret_cast<ffxQueryDescUpscaleGetUpscaleRatioFromQualityMode*>(header);
        float ratio = ffxFsr3UpscalerGetUpscaleRatioFromQualityMode(ConvertEnum<FfxApiUpscaleQualityMode>(desc->qualityMode));

        if (desc->pOutUpscaleRatio != nullptr)
        {
            *desc->pOutUpscaleRatio = ratio;
        }
        break;
    }
    case FFX_API_QUERY_DESC_TYPE_UPSCALE_GPU_MEMORY_USAGE:
    {
        VERIFY(context, FFX_API_RETURN_ERROR_PARAMETER);
        VERIFY(*context, FFX_API_RETURN_ERROR_PARAMETER);
        
        InternalFsr4Context* internal_context = reinterpret_cast<InternalFsr4Context*>(*context);
        auto desc = reinterpret_cast<ffxQueryDescUpscaleGetGPUMemoryUsage*>(header);

        VERIFY(desc->gpuMemoryUsageUpscaler, FFX_API_RETURN_ERROR_PARAMETER);

        memset(desc->gpuMemoryUsageUpscaler, 0, sizeof(FfxApiEffectMemoryUsage));

        TRY2(internal_context->backendInterface.fpGetEffectGpuMemoryUsage(&internal_context->backendInterface, internal_context->effectContextId, reinterpret_cast <FfxApiEffectMemoryUsage*> (desc->gpuMemoryUsageUpscaler)));

        break;
    }
    case FFX_API_QUERY_DESC_TYPE_UPSCALE_GPU_MEMORY_USAGE_V2:
    {
        ffxQueryDescUpscaleGetGPUMemoryUsageV2* desc = reinterpret_cast<ffxQueryDescUpscaleGetGPUMemoryUsageV2*>(header);

        VERIFY(desc->gpuMemoryUsageUpscaler, FFX_API_RETURN_ERROR_PARAMETER);

        memset(desc->gpuMemoryUsageUpscaler, 0, sizeof(FfxApiEffectMemoryUsage));

        FfxFsr4UpscalerResourceDescriptions fsr4UpscalerResourceDescs = {};
        getResourceDescriptions(&(desc->maxRenderSize), &(desc->maxUpscaleSize), &fsr4UpscalerResourceDescs);

        const FfxCreateResourceDescription* resources[] = {
            &fsr4UpscalerResourceDescs.recurrent,
            &fsr4UpscalerResourceDescs.history,
            &fsr4UpscalerResourceDescs.historyReprojected,
            &fsr4UpscalerResourceDescs.rcasIntermediary,
            &fsr4UpscalerResourceDescs.autoExposure,
            &fsr4UpscalerResourceDescs.defaultExposure,
            &fsr4UpscalerResourceDescs.spdAtomicCounter,
            &fsr4UpscalerResourceDescs.lumaMip5,
            &fsr4UpscalerResourceDescs.scratchBuffer,
            &fsr4UpscalerResourceDescs.initializerBuffer,
            &fsr4UpscalerResourceDescs.initializerBufferUpload,
            &fsr4UpscalerResourceDescs.debugInformation
        };

        uint64_t      size = 0;
        size_t resourceCount = sizeof(resources) / sizeof(resources[0]);
        const bool bAllowDebugVisualization = (desc->flags & FFX_UPSCALE_ENABLE_DEBUG_VISUALIZATION) == FFX_UPSCALE_ENABLE_DEBUG_VISUALIZATION;
        for (size_t i = 0; i < resourceCount; ++i)
        {
            if (!bAllowDebugVisualization && resources[i]->id == FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_DEBUG_INFORMATION)
            {
                continue;
            }
#ifdef FFX_BACKEND_DX12
            FFX_VALIDATE(ffxGetResourceSizeFromDescriptionDX12(static_cast<FfxDevice>(desc->device), resources[i], &size));
#endif // FFX_BACKEND_DX12
            desc->gpuMemoryUsageUpscaler->totalUsageInBytes += size;
            if (resources[i]->resourceDescription.flags & FFX_API_RESOURCE_FLAGS_ALIASABLE)
            {
                desc->gpuMemoryUsageUpscaler->aliasableUsageInBytes += size;
            }
        }

        break;
    }
    case FFX_API_QUERY_DESC_TYPE_UPSCALE_GET_RESOURCE_REQUIREMENTS:
    {
        auto desc = reinterpret_cast<ffxQueryDescUpscaleGetResourceRequirements*>(header);   
        
        desc->required_resources = 
            FFX_API_QUERY_RESOURCE_INPUT_COLOR |
            FFX_API_QUERY_RESOURCE_INPUT_DEPTH |
            FFX_API_QUERY_RESOURCE_INPUT_MV    |
            FFX_API_QUERY_RESOURCE_INPUT_EXPOSURE;
        desc->optional_resources = 0;

        break;
    }
    default:
        return FFX_API_RETURN_ERROR_UNKNOWN_DESCTYPE;
    }

    return FFX_API_RETURN_OK;
}

static void scheduleDispatch(InternalFsr4Context* context, const FfxPipelineState* pipeline, uint32_t dispatchX, uint32_t dispatchY, uint32_t dispatchZ, uint32_t flags=FFX_GPU_JOB_FLAGS_NONE)
{
    FfxComputeJobDescription jobDescriptor = {};

    for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvTextureCount; ++currentShaderResourceViewIndex) {

        const uint32_t currentResourceId = pipeline->srvTextureBindings[currentShaderResourceViewIndex].resourceIdentifier;
        const FfxResourceInternal currentResource = context->srvResources[currentResourceId];
        jobDescriptor.srvTextures[currentShaderResourceViewIndex].resource = currentResource;
#ifdef FFX_DEBUG
        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
#endif
    }

        for (uint32_t currentShaderResourceViewIndex = 0; currentShaderResourceViewIndex < pipeline->srvBufferCount; ++currentShaderResourceViewIndex)
    {
        const uint32_t currentResourceId = pipeline->srvBufferBindings[currentShaderResourceViewIndex].resourceIdentifier;
        const FfxResourceInternal currentResource = context->srvResources[currentResourceId];

        jobDescriptor.srvBuffers[currentShaderResourceViewIndex].resource = currentResource;
#ifdef FFX_DEBUG
        wcscpy_s(jobDescriptor.srvTextures[currentShaderResourceViewIndex].name, pipeline->srvTextureBindings[currentShaderResourceViewIndex].name);
#endif
    }

    for (uint32_t currentUnorderedAccessViewIndex = 0; currentUnorderedAccessViewIndex < pipeline->uavTextureCount; ++currentUnorderedAccessViewIndex) {

        const uint32_t currentResourceId = pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
#ifdef FFX_DEBUG
        wcscpy_s(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
#endif
        const FfxResourceInternal currentResource = context->uavResources[currentResourceId];
        jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].resource = currentResource;
        jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].mip = 0;
    }

    for (uint32_t currentUnorderedAccessViewIndex = 0; currentUnorderedAccessViewIndex < pipeline->uavBufferCount; ++currentUnorderedAccessViewIndex)
    {
        const uint32_t currentResourceId = pipeline->uavBufferBindings[currentUnorderedAccessViewIndex].resourceIdentifier;
#ifdef FFX_DEBUG
        wcscpy_s(jobDescriptor.uavTextures[currentUnorderedAccessViewIndex].name, pipeline->uavTextureBindings[currentUnorderedAccessViewIndex].name);
#endif
        {
            const FfxResourceInternal currentResource = context->uavResources[currentResourceId];
            jobDescriptor.uavBuffers[currentUnorderedAccessViewIndex].resource = currentResource;
        }
    }

    // TODO: raw buffers?

    jobDescriptor.dimensions[0] = dispatchX;
    jobDescriptor.dimensions[1] = dispatchY;
    jobDescriptor.dimensions[2] = dispatchZ;
    jobDescriptor.pipeline = *pipeline;

    for (uint32_t currentRootConstantIndex = 0; currentRootConstantIndex < pipeline->constCount; ++currentRootConstantIndex) {
#ifdef FFX_DEBUG
        wcscpy_s( jobDescriptor.cbNames[currentRootConstantIndex], pipeline->constantBufferBindings[currentRootConstantIndex].name);
#endif
        jobDescriptor.cbs[currentRootConstantIndex] = context->constantBuffers[pipeline->constantBufferBindings[currentRootConstantIndex].resourceIdentifier];
    }

    FfxGpuJobDescription dispatchJob = { FFX_GPU_JOB_COMPUTE };
    wcscpy_s(dispatchJob.jobLabel, pipeline->name);
    dispatchJob.computeJobDescriptor = jobDescriptor;
    dispatchJob.computeJobDescriptor.flags = flags;

    context->backendInterface.fpScheduleGpuJob(&context->backendInterface, &dispatchJob);
}

static int GetPaddingAmount(const std::tuple<uint32_t, uint32_t>& encoderResolution, const fsr4_shaders::DispatchSize& outputPadding)
{
    return 2 * std::get<0>(encoderResolution) * outputPadding.y + 2 * (std::get<1>(encoderResolution) - 2 * outputPadding.y) * outputPadding.z;
}

ffxReturnCode_t ffxProvider_FSR4::Dispatch(ffxContext* context, const ffxDispatchDescHeader* header) const
{
    VERIFY(context, FFX_API_RETURN_ERROR_PARAMETER);
    VERIFY(*context, FFX_API_RETURN_ERROR_PARAMETER);
    VERIFY(header, FFX_API_RETURN_ERROR_PARAMETER);

    InternalFsr4Context* internal_context = reinterpret_cast<InternalFsr4Context*>(*context);

    CheckDelayedPipelineDestruction(internal_context);

    switch (header->type)
    {
    case FFX_API_DISPATCH_DESC_TYPE_UPSCALE:
    {
        auto desc = reinterpret_cast<const ffxDispatchDescUpscale*>(header);

        uint32_t upscaleWidth  = AlignUp(desc->upscaleSize.width, 8u);
        uint32_t upscaleHeight = AlignUp(desc->upscaleSize.height, 8u);
        if (upscaleWidth == 0 && upscaleHeight == 0)
        {
            upscaleWidth  = internal_context->maxUpscaleSize.width;
            upscaleHeight = internal_context->maxUpscaleSize.height;
        }

        // Dispatch size logic
        std::array<fsr4_shaders::DispatchSize, 14> dispatchSizes;
        std::array<fsr4_shaders::DispatchSize, 13> paddingDispatchSizes;
        std::array<std::tuple<uint32_t, uint32_t>, 3> encoderResolutions;
        std::tuple<uint32_t, uint32_t> targetRes = std::tuple<uint32_t, uint32_t>(upscaleWidth, upscaleHeight);
        for (int i = 0; i < 3; ++i)
            encoderResolutions[i] = std::tuple<uint32_t, uint32_t>(upscaleWidth / (1u << (i+1)), upscaleHeight / (1u << (i+1)));

        if (internal_context->supportsWmma)
        {
            dispatchSizes[1] = {RoundUpDiv(std::get<0>(encoderResolutions[0]), 16u), RoundUpDiv(std::get<1>(encoderResolutions[0]), 8u), 1};
            dispatchSizes[2] = dispatchSizes[1];

            dispatchSizes[3] = {RoundUpDiv(std::get<0>(encoderResolutions[1]), 32u), std::get<1>(encoderResolutions[1]), 1};
            dispatchSizes[4] = {RoundUpDiv(std::get<0>(encoderResolutions[1]), 32u), RoundUpDiv(std::get<1>(encoderResolutions[1]), 4u), 1};
            dispatchSizes[5] = dispatchSizes[4];

            dispatchSizes[6] = {RoundUpDiv(std::get<0>(encoderResolutions[2]), 32u), std::get<1>(encoderResolutions[2]), 1};
            dispatchSizes[7] = dispatchSizes[6];
            dispatchSizes[8] = dispatchSizes[6];

            dispatchSizes[9] = dispatchSizes[6];
            dispatchSizes[10] = {RoundUpDiv(std::get<0>(encoderResolutions[1]), 32u), RoundUpDiv(std::get<1>(encoderResolutions[1]), 4u), 1};
            dispatchSizes[11] = {RoundUpDiv(std::get<0>(encoderResolutions[1]), 32u), std::get<1>(encoderResolutions[1]), 1};

            dispatchSizes[12] = {RoundUpDiv(std::get<0>(encoderResolutions[0]), 16u), RoundUpDiv(std::get<1>(encoderResolutions[0]), 8u), 1};

            // Padding
            const fsr4_shaders::DispatchSize outputPadding = {0, 1, 1};
            paddingDispatchSizes[0] = {uint32_t(std::ceil(GetPaddingAmount(encoderResolutions[0], outputPadding) / 32)),1,1};
            paddingDispatchSizes[1] = paddingDispatchSizes[0];
            paddingDispatchSizes[2] = paddingDispatchSizes[0];

            paddingDispatchSizes[3] = {uint32_t(std::ceil(GetPaddingAmount(encoderResolutions[1], outputPadding) / 32)),1,1};
            paddingDispatchSizes[4] = paddingDispatchSizes[3];
            paddingDispatchSizes[5] = paddingDispatchSizes[3];

            paddingDispatchSizes[6] = {uint32_t(std::ceil(GetPaddingAmount(encoderResolutions[2], outputPadding) / 32)),1,1};
            paddingDispatchSizes[7] = paddingDispatchSizes[6];
            paddingDispatchSizes[8] = paddingDispatchSizes[6];

            paddingDispatchSizes[9] = {uint32_t(std::ceil(GetPaddingAmount(encoderResolutions[1], outputPadding) / 32)),1,1};
            paddingDispatchSizes[10] = paddingDispatchSizes[9];

            paddingDispatchSizes[11] = {uint32_t(std::ceil(GetPaddingAmount(encoderResolutions[0], outputPadding) / 32)),1,1};
            paddingDispatchSizes[12] = paddingDispatchSizes[11];
        }


        else
        {
            dispatchSizes[1] = {RoundUpDiv(std::get<0>(encoderResolutions[0]), 64u), std::get<1>(encoderResolutions[0]), 1};
            dispatchSizes[2] = dispatchSizes[1];

            dispatchSizes[3] = {RoundUpDiv(std::get<0>(encoderResolutions[1]), 64u), std::get<1>(encoderResolutions[1]), 1};
            dispatchSizes[4] = dispatchSizes[3];
            dispatchSizes[5] = dispatchSizes[3];

            dispatchSizes[6] = {RoundUpDiv(std::get<0>(encoderResolutions[2]), 64u), std::get<1>(encoderResolutions[2]), 1};
            dispatchSizes[7] = dispatchSizes[6];
            dispatchSizes[8] = dispatchSizes[6];

            dispatchSizes[9] = {RoundUpDiv(std::get<0>(encoderResolutions[2]), 8u), RoundUpDiv(std::get<1>(encoderResolutions[2]), 8u), 1};
            dispatchSizes[10] = {RoundUpDiv(std::get<0>(encoderResolutions[1]), 64u), std::get<1>(encoderResolutions[1]), 1};
            dispatchSizes[11] = dispatchSizes[10];

            dispatchSizes[12] = {RoundUpDiv(std::get<0>(encoderResolutions[0]), 64u), std::get<1>(encoderResolutions[0]), 1};
        }

        fsr4_shaders::Preset correctPreset = fsr4_shaders::Preset::NativeAA;
        float                scalingRatio  = static_cast<float>(upscaleWidth) / static_cast<float>(desc->renderSize.width);
        //OutputDebugStringA((std::to_string(scalingRatio) + "\n").c_str());
        if (scalingRatio >= 1.50f) correctPreset = fsr4_shaders::Preset::Quality;
        if (scalingRatio >= 1.69f) correctPreset = fsr4_shaders::Preset::Balanced;
        if (scalingRatio >= 1.99f) correctPreset = fsr4_shaders::Preset::Performance;
        if (scalingRatio >= 2.99f) correctPreset = fsr4_shaders::Preset::UltraPerformance;
        // Never change away from drs preset.
        if (internal_context->modelPreset == fsr4_shaders::Preset::DRS)
            correctPreset = fsr4_shaders::Preset::DRS;

        // Update colorspace flags, change model if needed.
        const bool newColorspaceSrgb = ((desc->flags & FFX_UPSCALE_FLAG_NON_LINEAR_COLOR_SRGB) == FFX_UPSCALE_FLAG_NON_LINEAR_COLOR_SRGB);
        const bool newColorspacePq = ((desc->flags & FFX_UPSCALE_FLAG_NON_LINEAR_COLOR_PQ) == FFX_UPSCALE_FLAG_NON_LINEAR_COLOR_PQ);

        const bool debugViewFlagProvided = (desc->flags & FFX_UPSCALE_FLAG_DRAW_DEBUG_VIEW);
        const bool debugViewEnabled = internal_context->allowDebugVisualization && debugViewFlagProvided;
        if (debugViewFlagProvided)
            VERIFY(internal_context->allowDebugVisualization, FFX_API_RETURN_ERROR_PARAMETER);  // Warning would be better, but FSR4 is currently not hooking into the message callback.

        bool flagChangeEvent = false;

        if ((internal_context->colorspaceSrgb != newColorspaceSrgb) || (internal_context->colorspacePq != newColorspacePq))
        {
            flagChangeEvent = true;
            internal_context->colorspaceSrgb = newColorspaceSrgb;
            internal_context->colorspacePq = newColorspacePq;
            if (internal_context->colorspaceSrgb || internal_context->colorspacePq)
            {
                // srgb or pq override this global assumtion flag
                internal_context->nonlinearColorspace = false;
            }
            else if (!internal_context->colorspaceSrgb && !internal_context->colorspacePq)
            {
                //restore original colorspace
                internal_context->nonlinearColorspace =
                    (internal_context->createFlags & FFX_UPSCALE_ENABLE_NON_LINEAR_COLORSPACE) == FFX_UPSCALE_ENABLE_NON_LINEAR_COLORSPACE;
            }
        }

        bool forceReset = false;
        if (internal_context->modelCreated == false ||
            flagChangeEvent ||
            (internal_context->modelPreset != correctPreset && internal_context->modelPreset != fsr4_shaders::Preset::DRS))
        {
            // Re-create model. This is slow!
            FSR4_ASSERT(CreateModel(internal_context, correctPreset) == FFX_API_RETURN_OK);
            internal_context->modelPreset = correctPreset;
            internal_context->modelCreated = true;
            forceReset = true;
        }

        // Dispatch FSR4
        internal_context->cbufferData.main.inv_size[0]     = 1.0f / upscaleWidth;
        internal_context->cbufferData.main.inv_size[1]     = 1.0f / upscaleHeight;
        internal_context->cbufferData.main.scale[0]        = 1.f * upscaleWidth / desc->renderSize.width;
        internal_context->cbufferData.main.scale[1]        = 1.f * upscaleHeight / desc->renderSize.height;
        internal_context->cbufferData.main.inv_scale[0]    = 1.f / internal_context->cbufferData.main.scale[0];
        internal_context->cbufferData.main.inv_scale[1]    = 1.f / internal_context->cbufferData.main.scale[1];
        internal_context->cbufferData.main.jitter[0]       = desc->jitterOffset.x;
        internal_context->cbufferData.main.jitter[1]       = desc->jitterOffset.y;

        const FfxApiDimensions2D& mvSize = (internal_context->lowResMv ? desc->renderSize : desc->upscaleSize);

        internal_context->cbufferData.main.mv_scale[0] = desc->motionVectorScale.x / mvSize.width;
        internal_context->cbufferData.main.mv_scale[1] = desc->motionVectorScale.y / mvSize.height;

        if (internal_context->motionVectorJitterCancellation)
        {
            internal_context->cbufferData.main.fMotionVectorJitterCancellation[0] =
                (internal_context->previousJitter[0] - internal_context->cbufferData.main.jitter[0]) / mvSize.width;
            internal_context->cbufferData.main.fMotionVectorJitterCancellation[1] = (internal_context->previousJitter[1] - internal_context->cbufferData.main.jitter[1]) / mvSize.height;

            internal_context->previousJitter[0] = internal_context->cbufferData.main.jitter[0];
            internal_context->previousJitter[1] = internal_context->cbufferData.main.jitter[1];
        }

        internal_context->cbufferData.main.max_renderSize[0] = static_cast<float>(internal_context->maxRenderSize.width);
        internal_context->cbufferData.main.max_renderSize[1] = static_cast<float>(internal_context->maxRenderSize.height);
        internal_context->cbufferData.main.tex_size[0] = static_cast<float>(internal_context->maxUpscaleSize.width);
        internal_context->cbufferData.main.tex_size[1] = static_cast<float>(internal_context->maxUpscaleSize.height);
        internal_context->cbufferData.main.width = upscaleWidth;
        internal_context->cbufferData.main.height = upscaleHeight;
        internal_context->cbufferData.main.reset = desc->reset || forceReset;
        internal_context->cbufferData.main.width_lr = desc->renderSize.width;
        internal_context->cbufferData.main.height_lr = desc->renderSize.height;

        internal_context->cbufferData.main.previous_preExposure = internal_context->cbufferData.main.preExposure;
        internal_context->cbufferData.main.preExposure = desc->preExposure;

        internal_context->cbufferData.main.rcas_enabled = desc->enableSharpening;
        internal_context->cbufferData.main.rcas_sharpness = desc->sharpness;

        internal_context->backendInterface.fpStageConstantBufferDataFunc(&internal_context->backendInterface,
                                                                         &internal_context->cbufferData.main,
                                                                         sizeof(internal_context->cbufferData.main),
                                                                         &internal_context->constantBuffers[FFX_FSR4UPSCALER_CONSTANTBUFFER_IDENTIFIER_FSR4UPSCALER]);

        FfxApiResource colorApiResource    = desc->color;
        FfxApiResource depthApiResource    = desc->depth;
        FfxApiResource mvApiResource       = desc->motionVectors;
        FfxApiResource exposureApiResource = desc->exposure;
        FfxApiResource outputApiResource   = desc->output;

        internal_context->backendInterface.fpStageConstantBufferDataFunc(&internal_context->backendInterface,
                                                                         &internal_context->cbufferData.rcas,
                                                                         sizeof(internal_context->cbufferData.rcas),
                                                                         &internal_context->constantBuffers[FFX_FSR4UPSCALER_CONSTANTBUFFER_IDENTIFIER_RCAS]);

        internal_context->backendInterface.fpStageConstantBufferDataFunc(&internal_context->backendInterface,
                                                                         &internal_context->cbufferData.pass0_weights,
                                                                         sizeof(internal_context->cbufferData.pass0_weights),
                                                                         &internal_context->constantBuffers[FFX_FSR4UPSCALER_CONSTANTBUFFER_IDENTIFIER_PASS_WEIGHTS]);


        internal_context->backendInterface.fpRegisterResource(
            &internal_context->backendInterface,
            &colorApiResource,
            internal_context->effectContextId,
            &internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_COLOR]);

        internal_context->backendInterface.fpRegisterResource(
            &internal_context->backendInterface,
            &depthApiResource,
            internal_context->effectContextId,
            &internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_DEPTH]);

        internal_context->backendInterface.fpRegisterResource(
            &internal_context->backendInterface,
            &mvApiResource,
            internal_context->effectContextId,
            &internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS]);

        if (ffxFsr4UpscalerResourceIsNull(exposureApiResource))
        {
            internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_EXPOSURE] =
                internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_EXPOSURE];
        }
        else
        {
            internal_context->backendInterface.fpRegisterResource(&internal_context->backendInterface,
                                                                  &exposureApiResource,
                                                                  internal_context->effectContextId,
                                                                  &internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_INPUT_EXPOSURE]);
        }

        internal_context->backendInterface.fpRegisterResource(&internal_context->backendInterface,
                                                        &outputApiResource,
                                                        internal_context->effectContextId,
                                                        &internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_FINAL_OUTPUT]);

        if (desc->enableSharpening)
        {
            internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_MLSR_OUTPUT] =
                internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RCAS_TEMP];

            internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RCAS_OUTPUT] =
                internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_FINAL_OUTPUT];

            internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RCAS_OUTPUT] =
                internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_FINAL_OUTPUT];
        }
        else
        {
            internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_MLSR_OUTPUT] =
                internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_FINAL_OUTPUT];
        }

        internal_context->srvResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_RESULT_COLOR] =
            internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_FINAL_OUTPUT];

        if (debugViewEnabled)
        {
            FfxGpuJobDescription clearJob = {FFX_GPU_JOB_CLEAR_FLOAT};
            wcscpy_s(clearJob.jobLabel, L"Clear Debug Information");
            memset(clearJob.clearJobDescriptor.color, 0, 4 * sizeof(float));
            clearJob.clearJobDescriptor.target = internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_DEBUG_INFORMATION];
            internal_context->backendInterface.fpScheduleGpuJob(&internal_context->backendInterface, &clearJob);
        }

        // AutoExposure
        if (internal_context->autoExposure)
        {
            uint32_t dispatchThreadGroupCountXY[2];
            uint32_t workGroupOffset[2];
            uint32_t numWorkGroupsAndMips[2];
            uint32_t rectInfo[4] = {0, 0, desc->renderSize.width, desc->renderSize.height};
            ffxSpdSetup(dispatchThreadGroupCountXY, workGroupOffset, numWorkGroupsAndMips, rectInfo);

            internal_context->cbufferData.spdAutoExposure.workGroupOffset[0] = workGroupOffset[0];
            internal_context->cbufferData.spdAutoExposure.workGroupOffset[1] = workGroupOffset[1];
            internal_context->cbufferData.spdAutoExposure.numWorkGroups = numWorkGroupsAndMips[0];
            internal_context->cbufferData.spdAutoExposure.mips = numWorkGroupsAndMips[1];
            internal_context->cbufferData.spdAutoExposure.preExposure = desc->preExposure;
            internal_context->cbufferData.spdAutoExposure.invInputSize[0] = 1.0f / desc->renderSize.width;
            internal_context->cbufferData.spdAutoExposure.invInputSize[1] = 1.0f / desc->renderSize.height;

            internal_context->backendInterface.fpStageConstantBufferDataFunc(
                &internal_context->backendInterface,
                &internal_context->cbufferData.spdAutoExposure,
                sizeof(internal_context->cbufferData.spdAutoExposure),
                &internal_context->constantBuffers[FFX_FSR4UPSCALER_CONSTANTBUFFER_IDENTIFIER_SPD_AUTOEXPOSURE]);

            scheduleDispatch(internal_context, &internal_context->spd_auto_exposure_pso, dispatchThreadGroupCountXY[0], dispatchThreadGroupCountXY[1], 1);
        }


        // Pre-pass
        if (internal_context->supportsWmma)
        {
            const auto paddingDispatch = paddingDispatchSizes[0];
            scheduleDispatch(internal_context, &internal_context->model_pso[0], RoundUpDiv(upscaleWidth, 64ui32), RoundUpDiv(upscaleHeight, 2ui32), 1);
            scheduleDispatch(internal_context, &internal_context->padding_pso[0], paddingDispatch.x, paddingDispatch.y, paddingDispatch.z, FFX_GPU_JOB_FLAGS_SKIP_BARRIERS);
        }
        else
        {
            const uint32_t preGroupSize = 16;
            scheduleDispatch(internal_context, &internal_context->model_pso[0], RoundUpDiv(upscaleWidth, preGroupSize), RoundUpDiv(upscaleHeight, preGroupSize), 1);
        }


        // ML passes
        for (int i = 1; i < 13; ++i)
        {
            const auto dispatch = dispatchSizes[i];
            scheduleDispatch(internal_context, &internal_context->model_pso[i], dispatch.x, dispatch.y, dispatch.z);
            if (internal_context->supportsWmma)
            {
                const auto paddingDispatch = paddingDispatchSizes[i];
                if (i != 6)
                    scheduleDispatch(internal_context, &internal_context->padding_pso[i], paddingDispatch.x, paddingDispatch.y, paddingDispatch.z, FFX_GPU_JOB_FLAGS_SKIP_BARRIERS);
            }
        }


        // Post-pass
        const uint32_t postGroupSize = 8;
        const uint32_t pixelsPerThreadPerDim = 2;
        if (internal_context->supportsWmma)
        {
            scheduleDispatch(internal_context, &internal_context->model_pso[13], RoundUpDiv(upscaleWidth, 64ui32), RoundUpDiv(upscaleHeight, 2ui32), 1);
        }
        else
        {
            scheduleDispatch(internal_context, &internal_context->model_pso[13], RoundUpDiv(upscaleWidth, postGroupSize * pixelsPerThreadPerDim), RoundUpDiv(upscaleHeight, postGroupSize * pixelsPerThreadPerDim), 1);
        }

        // RCAS sharpening
        if (desc->enableSharpening)
        {
            internal_context->cbufferData.rcas.preExposure = desc->preExposure;

            const float sharpenessRemapped = (-2.0f * desc->sharpness) + 2.0f;
            FsrRcasCon(internal_context->cbufferData.rcas.config, sharpenessRemapped);

            internal_context->backendInterface.fpStageConstantBufferDataFunc(
                &internal_context->backendInterface,
                &internal_context->cbufferData.rcas,
                sizeof(internal_context->cbufferData.rcas),
                &internal_context->constantBuffers[FFX_FSR4UPSCALER_CONSTANTBUFFER_IDENTIFIER_RCAS]);


            scheduleDispatch(internal_context, &internal_context->rcas_pso,RoundUpDiv(upscaleWidth, postGroupSize * pixelsPerThreadPerDim), RoundUpDiv(upscaleHeight, postGroupSize * pixelsPerThreadPerDim), 1);
        }

        // Debug view
        if (debugViewEnabled)
        {
            scheduleDispatch(internal_context, &internal_context->debug_view_pso, RoundUpDiv(upscaleWidth, 8ui32), RoundUpDiv(upscaleHeight, 8ui32), 1);
        }

        // Watermark
        if (internal_context->watermark)
        {
            FfxResourceInternal target = internal_context->uavResources[FFX_FSR4UPSCALER_RESOURCE_IDENTIFIER_FINAL_OUTPUT];
            std::array<char, 480> watermarkMessage{};

            std::string_view colorspaceName;
            if (internal_context->colorspacePq)
                colorspaceName = "PQ"sv;
            else if (internal_context->colorspaceSrgb)
                colorspaceName = "SRGB"sv;
            else if (internal_context->nonlinearColorspace)
                colorspaceName = "NON-LINEAR"sv;
            else
                colorspaceName = "LINEAR"sv;

            std::format_to_n(watermarkMessage.begin(), watermarkMessage.size(), "MLSR Upscale {}\nBuild time: {} {}\nGit branch: {}  commit: {}\nColorspace: {}\0"sv,
                internal_context->supportsWmma ? "wmma"sv : "v07-i8"sv,
                __DATE__,
                __TIME__,
                GIT_COMMIT_SUBJECT,
                GIT_HASH,
                colorspaceName);
            internal_context->watermark->Dispatch(target, watermarkMessage.data());
        }
        internal_context->backendInterface.fpExecuteGpuJobs(&internal_context->backendInterface, desc->commandList, internal_context->effectContextId);

        internal_context->backendInterface.fpUnregisterResources(&internal_context->backendInterface, desc->commandList, internal_context->effectContextId);

        internal_context->frameIdx++;

        break;
    }
    case FFX_API_DISPATCH_DESC_TYPE_UPSCALE_GENERATEREACTIVEMASK:
    {
        // do nothing.

        break;
    }
    default:
        return FFX_API_RETURN_ERROR_UNKNOWN_DESCTYPE;
    }

    return FFX_API_RETURN_OK;
}

ffxProvider_FSR4 ffxProvider_FSR4::Instance;
#pragma warning(pop)
